<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BF6 Mastery Loadout Tracker</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #05090d;
      --panel: #0f161c;
      --panel-border: #1c252f;
      --accent: #00e5ff; /* BF6-style cyan */
      --accent-soft: rgba(0, 229, 255, 0.16);
      --ally: #00d1ff; /* Ally blue (refined) */
      --ally-soft: rgba(0, 209, 255, 0.18);
      --enemy: #ff3b3b; /* Enemy red (refined) */
      --enemy-soft: rgba(255, 59, 59, 0.2);
      --text: #f5f8fa;
      --text-muted: #95a3b1;
      --danger: #ff6b6b;
      --card-padding: 12px;
      --indent: 36px;
      --card-radius: 7px;
      --transition: 160ms ease;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
      --font: "Futura ND", "Futura", "Helvetica Neue", Arial, sans-serif;
      --ui-scale: 1; /* 1.0 = 100% */
      --level-slider-fill: 0%;
    }

    * {
      box-sizing: border-box;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Ensure hidden elements do not render */
    [hidden] { display: none !important; }

    body {
      margin: 0;
      background: radial-gradient(1000px 600px at 80% -100px, rgba(0, 229, 255, 0.12), transparent 60%),
        linear-gradient(180deg, rgba(10, 18, 25, 0.9) 0%, rgba(5, 9, 13, 0.96) 60%, rgba(5, 9, 13, 1) 100%),
        var(--bg);
      color: var(--text);
      font-family: var(--font);
      font-size: calc(16px * var(--ui-scale));
      line-height: 1.5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: clamp(16px, 4vw, 32px);
      overflow-x: auto;
    }

    .layout-grid {
      width: min(1400px, 100%);
      display: grid;
      grid-template-columns: minmax(220px, 260px) minmax(0, 1fr) minmax(220px, 280px);
      grid-template-areas: "nav main options";
      gap: 24px;
      align-items: start;
      transform: scale(var(--ui-scale));
      transform-origin: top center;
      will-change: transform;
    }

    .layout-grid.options-hidden {
      grid-template-columns: minmax(220px, 260px) minmax(0, 1fr) 0;
    }

    .app-shell {
      grid-area: main;
      min-width: 0;
    }

    .app {
      width: 100%;
      background: rgba(8, 12, 16, 0.55);
      border: 1px solid rgba(120, 160, 180, 0.14);
      border-radius: 16px;
      padding: 20px 24px;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      gap: 24px;
      position: relative;
    }

    .app::before {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.08;
      background-image: 
        repeating-linear-gradient(90deg, rgba(180, 200, 220, 0.12) 0 1px, transparent 1px 24px),
        repeating-linear-gradient(0deg, rgba(180, 200, 220, 0.10) 0 1px, transparent 1px 24px);
      mask-image: radial-gradient(80% 60% at 50% 10%, black, transparent 80%);
    }

    .page-header {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .page-title {
      font-size: clamp(24px, 4vw, 32px);
      font-weight: 700;
      letter-spacing: 0.02em;
      margin: 0;
    }

    .page-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin: 0;
      max-width: 660px;
    }

    .weapon-list {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .weapon-card {
      background: rgba(10, 16, 21, 0.6);
      border-radius: 14px;
      border: 1px solid rgba(80, 120, 140, 0.18);
      display: flex;
      flex-direction: column;
      padding: 10px 12px;
      gap: 10px;
      transition: box-shadow var(--transition), border-color var(--transition), background var(--transition);
      position: relative;
      z-index: 0;
      overflow: visible;
      outline: none;
    }

    .weapon-card::before {
      content: "";
      position: absolute;
      left: 10px;
      right: 10px;
      top: 0;
      height: 2px;
      border-radius: 2px;
      background: linear-gradient(90deg, transparent, rgba(0, 229, 255, 0.55), transparent);
      pointer-events: none;
    }

    .weapon-card:focus-visible {
      box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.6);
    }

    .weapon-card.dragging {
      opacity: 0.95;
      box-shadow: 0 28px 70px rgba(0, 0, 0, 0.65), 0 0 22px rgba(0, 229, 255, 0.4);
      border-color: rgba(0, 229, 255, 0.55);
      background: rgba(6, 12, 18, 0.75);
      will-change: background, box-shadow;
    }

    .weapon-card:hover {
      border-color: rgba(0, 229, 255, 0.25);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
      background: rgba(10, 16, 21, 0.62);
    }

    .drag-active .weapon-card:hover:not(.dragging) {
      border-color: rgba(80, 120, 140, 0.18);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.3);
      background: rgba(10, 16, 21, 0.55);
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; }
    }

    :root.reduce-animations .meta-chip,
    :root.reduce-animations .meta-chip::before,
    :root.reduce-animations .meta-chip::after,
    :root.reduce-animations .range-chip::after,
    :root.reduce-animations .meta-chip.rank-m::before,
    :root.reduce-animations .meta-chip.rank-m::after {
      animation: none !important;
    }

    :root.reduce-animations .meta-chip::before,
    :root.reduce-animations .meta-chip::after,
    :root.reduce-animations .meta-chip.rank-m::before,
    :root.reduce-animations .meta-chip.rank-m::after {
      content: none !important;
    }

    .weapon-card.favorite {
      border-color: rgba(0, 229, 255, 0.55);
      box-shadow: 0 0 0 1px rgba(0, 229, 255, 0.25), 0 16px 36px rgba(0, 229, 255, 0.14);
      background: rgba(10, 16, 21, 0.66);
    }

    .weapon-drop-placeholder {
      border: 2px dashed rgba(0, 255, 255, 0.85);
      border-radius: 14px;
      padding: 28px;
      color: rgba(0, 255, 255, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle, rgba(0, 229, 255, 0.22), rgba(0, 229, 255, 0.08));
      box-shadow: 0 0 26px rgba(0, 229, 255, 0.35);
      pointer-events: none;
    }

    .weapon-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
    }

    .weapon-header:active { cursor: grabbing; }

    .weapon-header-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      flex: 1 1 auto;
      min-width: 160px;
      position: relative;
      user-select: none;
      -webkit-user-select: none;
    }

    .weapon-name {
      font-size: clamp(20px, 3.6vw, 26px);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .weapon-image-wrap {
      flex: 0 0 auto;
      margin-left: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 110px;
      min-height: 38px;
    }

    .weapon-image {
      max-height: 38px;
      width: auto;
      border-radius: 6px;
      border: 1px solid rgba(60, 74, 85, 0.55);
      background: rgba(18, 26, 32, 0.88);
      object-fit: contain;
      box-shadow: 0 4px 10px rgba(0,0,0,0.25);
      display: block;
    }

    .weapon-image-ph {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      min-height: 38px;
      min-width: 110px;
      border-radius: 6px;
      border: 1px dotted rgba(120, 140, 156, 0.9);
      color: var(--text-muted);
      font-size: 12px;
      letter-spacing: 0.04em;
      background: rgba(18, 26, 32, 0.6);
      text-transform: none;
      user-select: none;
      -webkit-user-select: none;
    }

    .weapon-image-wrap.placeholder .weapon-image { display: none; }
    .weapon-image-wrap:not(.placeholder) .weapon-image-ph { display: none; }

    

    /* Meta chips under the weapon name */
    .weapon-meta-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 2px;
      flex-wrap: wrap;
    }

    .meta-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.09em;
      text-transform: uppercase;
      border: 1px solid rgba(60, 74, 85, 0.6);
      background: rgba(18, 26, 32, 0.88);
      color: #fff;
      user-select: none;
      -webkit-user-select: none;
      position: relative;
      overflow: hidden;
      z-index: 0;
      isolation: isolate;
      --chip-text-outline: rgba(0, 0, 0, 0.85);
      --chip-text-glow: 0 0 0 transparent;
      text-shadow:
        -0.7px -0.7px 0 var(--chip-text-outline),
        0.7px -0.7px 0 var(--chip-text-outline),
        -0.7px 0.7px 0 var(--chip-text-outline),
        0.7px 0.7px 0 var(--chip-text-outline),
        0 0 4px rgba(0, 0, 0, 0.65),
        var(--chip-text-glow);
      -webkit-text-stroke: 0.55px rgba(0, 0, 0, 0.6);
    }

    .meta-chip.type-chip {
      background: linear-gradient(135deg, rgba(0,229,255,0.18), rgba(0,229,255,0.08));
      border-color: rgba(0,229,255,0.45);
      color: #e9fbff;
      text-shadow: 0 0 6px rgba(0,229,255,0.28);
    }

    .meta-chip.rank-m { background: linear-gradient(135deg, #f1c40f, #d4a017); border-color: rgba(241,196,15,0.65); color: #132018; }
    .meta-chip.rank-a { background: linear-gradient(135deg, #00e5ff, #3aa6ff); border-color: rgba(0,229,255,0.55); color: #0a1620; }
    .meta-chip.rank-b { background: linear-gradient(135deg, #14d672, #0fb862); border-color: rgba(20,214,114,0.55); color: #0c1d16; }
    .meta-chip.rank-c { background: linear-gradient(135deg, #ffb15a, #ff8a3a); border-color: rgba(255,165,80,0.6); color: #23160c; }
    .meta-chip.rank-d { background: linear-gradient(135deg, #ff6b6b, #ff4444); border-color: rgba(255,107,107,0.6); color: #2a0f12; }
    .meta-chip.rank-unranked { background: linear-gradient(135deg, #7d5fff, #5a3dff); border-color: rgba(125,95,255,0.55); color: #f2f0ff; }

    .meta-chip.range-1 { background: linear-gradient(135deg, #f1c40f, #d4a017); border-color: rgba(241,196,15,0.65); color: #132018; }
    .meta-chip.range-2 { background: linear-gradient(135deg, #bdc3c7, #95a5a6); border-color: rgba(189,195,199,0.6); color: #141b1e; }
    .meta-chip.range-3 { background: linear-gradient(135deg, #cd7f32, #b9732c); border-color: rgba(205,127,50,0.65); color: #210f08; }
    .meta-chip.range-4 { background: linear-gradient(135deg, #5b7a8e, #3f5566); border-color: rgba(91,122,142,0.6); color: #e6eef5; }
    .meta-chip.range-unranked { background: linear-gradient(135deg, #7d5fff, #5a3dff); border-color: rgba(125,95,255,0.55); color: #f2f0ff; }

    .level-pill {
      background: rgba(0, 229, 255, 0.12);
      color: var(--accent);
      border: 1px solid rgba(0, 229, 255, 0.35);
      border-radius: 999px;
      padding: 5px 12px;
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      white-space: nowrap;
    }

    /* Header chevron chip */
    .chevron-toggle {
      position: absolute;
      top: -2px;
      right: -2px;
      border: 1px solid rgba(60, 74, 85, 0.55);
      background: rgba(18, 26, 32, 0.88);
      color: var(--text);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      transform: rotate(90deg);
      transition: transform var(--transition);
      user-select: none;
      -webkit-user-select: none;
    }

    .weapon-card.collapsed .chevron-toggle {
      transform: rotate(0deg);
    }

    /* Header condensed controls row */
    .header-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .header-level {
      color: #00e5ff;
      text-shadow: 0 0 8px rgba(0, 229, 255, 0.35);
      font-weight: 700;
      letter-spacing: 0.08em;
    }

    .header-sep { opacity: 0.6; }

    .header-controls .level-slider {
      width: min(280px, 42vw);
    }

    /* Hide header level pill; no collapsed indicator */
    .weapon-card .level-pill { display: none !important; }

    .favorite-toggle,
    .collapse-toggle,
    .collapse-box,
    .drag-handle {
      border: 1px solid rgba(60, 74, 85, 0.55);
      background: rgba(18, 26, 32, 0.88);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: background var(--transition), border-color var(--transition), color var(--transition);
    }

    .drag-handle { cursor: grab; display: none !important; }

    .weapon-card[data-active-build]:not([data-active-build="mastery"]) .level-pill,
    .weapon-card[data-active-build]:not([data-active-build="mastery"]) .weapon-body .level-controls {
      display: none !important;
    }

    .weapon-card[data-active-build]:not([data-active-build="mastery"]) .header-controls .level-button,
    .weapon-card[data-active-build]:not([data-active-build="mastery"]) .header-controls .level-slider,
    .weapon-card[data-active-build]:not([data-active-build="mastery"]) .header-level,
    .weapon-card[data-active-build]:not([data-active-build="mastery"]) .header-sep {
      display: none !important;
    }

    /* Hide legacy UI controls/labels when using header row */
    .collapse-toggle { display: none !important; }
    .favorite-toggle .favorite-text { display: none !important; }
    .build-tabs {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 2px 0;
    }

    .build-tablist {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .build-tab {
      border-radius: 999px;
      border: 1px solid rgba(120, 160, 180, 0.45);
      background: rgba(8, 12, 16, 0.8);
      color: inherit;
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 4px 12px;
      cursor: pointer;
      transition: border-color var(--transition), background var(--transition);
    }

    .build-tab.active,
    .build-tab:hover {
      border-color: rgba(0, 229, 255, 0.55);
      background: rgba(0, 229, 255, 0.12);
    }

    .recommended-panel { display: none !important; }

    .drag-handle:active { cursor: grabbing; }

    .filter-section {
      border: 1px solid rgba(120, 160, 180, 0.35);
      border-radius: 12px;
      padding: 10px;
      background: rgba(10, 16, 21, 0.75);
    }

    .filter-heading {
      font-size: 12px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: rgba(177, 191, 203, 0.95);
      margin-bottom: 8px;
    }

    .type-filter-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .type-filter-item {
      border: 1px solid rgba(120, 160, 180, 0.35);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: rgba(8, 12, 16, 0.85);
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition);
      text-align: left;
    }

    .type-filter-item.active {
      border-color: rgba(0, 229, 255, 0.7);
      background: rgba(0, 229, 255, 0.12);
    }

    .favorite-toggle:hover,
    .collapse-toggle:hover,
    .collapse-box:hover,
    .drag-handle:hover {
      background: rgba(0, 229, 255, 0.12);
      border-color: rgba(0, 229, 255, 0.35);
    }

    .favorite-toggle[aria-pressed="true"] {
      background: rgba(0, 229, 255, 0.18);
      border-color: rgba(0, 229, 255, 0.5);
      color: var(--accent);
    }

    .favorite-toggle span[aria-hidden="true"] {
      transition: transform 200ms ease, color 200ms ease;
    }

    .weapon-card.favorite {
      border-color: rgba(0, 229, 255, 0.55);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.5),
        0 0 22px rgba(0, 229, 255, 0.35),
        0 0 44px rgba(0, 160, 255, 0.2);
    }

    .weapon-card.favorite .favorite-toggle span[aria-hidden="true"] {
      color: #00f0ff;
      text-shadow:
        0 0 4px rgba(0, 229, 255, 0.6),
        0 0 12px rgba(0, 229, 255, 0.65);
    }

    .weapon-card.favorite .favorite-toggle {
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.35) inset, 0 0 16px rgba(0, 229, 255, 0.4);
    }

    /* Square icon-only controls */
    .favorite-toggle,
    .collapse-box {
      width: 34px;
      height: 34px;
      padding: 0;
      font-size: 18px;
      line-height: 1;
      text-transform: none;
    }

    .control-stack {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
    }

    .weapon-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .weapon-card.collapsed .weapon-body {
      display: none;
    }

    /* Left navigation within layout grid */
    .side-nav {
      grid-area: nav;
      padding: 12px;
      border: 1px solid var(--panel-border);
      background: rgba(10, 16, 21, 0.8);
      border-radius: 12px;
      box-shadow: 0 18px 30px rgba(0, 0, 0, 0.4);
      max-height: calc(100vh - 60px);
      overflow-y: auto;
      overflow-x: hidden;
      overscroll-behavior: contain;
      position: sticky;
      top: 24px;
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 229, 255, 0.45) rgba(6, 10, 14, 0.6);
    }

    .side-nav::-webkit-scrollbar {
      width: 8px;
    }

    .side-nav::-webkit-scrollbar-track {
      background: rgba(6, 10, 14, 0.8);
      border-radius: 999px;
    }

    .side-nav::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(0, 229, 255, 0.85), rgba(0, 120, 150, 0.7));
      border-radius: 999px;
      border: 1px solid rgba(0, 229, 255, 0.35);
      box-shadow: inset 0 0 6px rgba(0, 229, 255, 0.4);
    }

    .side-nav:not(.nav-ready) {
      visibility: hidden;
      pointer-events: none;
    }

    .side-nav-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .side-nav-item {
      border: 1px solid rgba(70, 90, 110, 0.6);
      background: rgba(8, 12, 16, 0.85);
      border-radius: 10px;
      padding: 8px;
      font-size: 12px;
      letter-spacing: 0.04em;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: grab;
      transition: background var(--transition), border-color var(--transition), box-shadow var(--transition);
      user-select: none;
      -webkit-user-select: none;
    }

    .side-nav-item:active {
      cursor: grabbing;
    }

    .side-nav-item:hover {
      border-color: rgba(0, 229, 255, 0.35);
      background: rgba(0, 229, 255, 0.1);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
    }

    .drag-active .side-nav-item:hover:not(.dragging) {
      border-color: rgba(70, 90, 110, 0.6);
      background: rgba(8, 12, 16, 0.85);
      box-shadow: none;
    }

    .side-nav-item.dragging {
      opacity: 0.95;
      border-color: rgba(0, 229, 255, 0.65);
      background: rgba(0, 229, 255, 0.22);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.45);
    }

    .side-nav-item.nav-drop-placeholder {
      border-style: dashed;
      border-color: rgba(0, 255, 255, 0.8);
      background: rgba(0, 229, 255, 0.15);
      color: rgba(0, 229, 255, 0.9);
      box-shadow: 0 0 16px rgba(0, 229, 255, 0.3);
      justify-content: center;
      pointer-events: none;
    }

    .side-nav-name {
      flex: 1 1 auto;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .side-nav-type {
      color: var(--text-muted);
      font-size: 11px;
      letter-spacing: 0.04em;
    }

    .side-nav-fav {
      color: var(--accent);
      font-size: 14px;
      line-height: 1;
      text-shadow: 0 0 6px rgba(0, 229, 255, 0.6);
    }

    @media (max-width: 1180px) {
      .layout-grid {
        grid-template-columns: minmax(0, 1fr);
        grid-template-areas:
          "main"
          "nav"
          "options";
      }

      .side-nav,
      .options-panel:not(.collapsed) {
        position: static;
        max-height: none;
      }
    }

    @media (max-width: 768px) {
      .layout-grid {
        gap: 16px;
      }

      .side-nav,
      .options-panel {
        padding: 12px;
      }
    }

    .options-panel {
      grid-area: options;
      padding: 14px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: rgba(12, 18, 24, 0.85);
      box-shadow: 0 18px 30px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 14px;
      position: sticky;
      top: 24px;
      max-height: calc(100vh - 60px);
    }

    .options-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .options-title {
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .options-gear {
      border: 1px solid rgba(70, 90, 110, 0.6);
      background: rgba(8, 12, 16, 0.9);
      color: var(--text);
      border-radius: 10px;
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition), color var(--transition);
    }

    .options-gear:hover {
      background: rgba(0, 229, 255, 0.12);
      border-color: rgba(0, 229, 255, 0.55);
    }

    .options-panel.collapsed {
      position: fixed;
      top: clamp(12px, 4vw, 28px);
      right: clamp(12px, 4vw, 28px);
      width: auto;
      padding: 0;
      border: none;
      box-shadow: none;
      background: transparent;
      max-height: none;
      gap: 0;
      pointer-events: none;
      z-index: 60;
    }

    .options-panel.collapsed .options-header {
      justify-content: flex-end;
    }

    .options-panel.collapsed .options-title,
    .options-panel.collapsed .options-body {
      display: none;
    }

    .options-panel.collapsed .options-gear {
      pointer-events: auto;
      border-color: rgba(0, 229, 255, 0.6);
      background: rgba(8, 16, 24, 0.9);
      box-shadow: 0 0 18px rgba(0, 229, 255, 0.35);
    }

    .options-floating-gear {
      position: fixed;
      top: clamp(12px, 4vw, 28px);
      right: clamp(12px, 4vw, 28px);
      width: 46px;
      height: 46px;
      border-radius: 14px;
      border: 1px solid rgba(0, 229, 255, 0.6);
      background: rgba(8, 16, 24, 0.92);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 80;
      box-shadow: 0 0 18px rgba(0, 229, 255, 0.35);
      transition: background var(--transition), border-color var(--transition), transform var(--transition);
    }

    .options-floating-gear:hover {
      transform: translateY(-1px);
      background: rgba(0, 229, 255, 0.12);
    }

    .gear-symbol {
      font-size: 20px;
      line-height: 1;
    }

    .options-body {
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

    .option-card {
      border: 1px solid rgba(70, 90, 110, 0.6);
      background: rgba(8, 12, 16, 0.92);
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: border-color var(--transition), background var(--transition), box-shadow var(--transition);
    }

    .option-card:hover {
      border-color: rgba(0, 229, 255, 0.35);
      background: rgba(8, 12, 16, 0.98);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }

    .option-heading {
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .option-card.ui-scale-card {
      gap: 10px;
    }

    .ui-scale-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .ui-scale-heading .option-heading {
      margin: 0;
      color: var(--text-muted);
    }

    .ui-scale-heading .ui-scale-value {
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 0 10px rgba(0, 229, 255, 0.45);
      font-size: 13px;
    }

    .ui-scale-card .ui-scale-slider {
      margin-top: 2px;
    }

    .options-toggle {
      cursor: pointer;
      align-items: center;
      flex-direction: row;
      justify-content: space-between;
    }

    .toggle-switch {
      width: 40px;
      height: 20px;
      border-radius: 999px;
      border: 1px solid rgba(60, 74, 85, 0.6);
      background: rgba(10, 16, 21, 0.8);
      position: relative;
      transition: background var(--transition), border-color var(--transition);
    }

    .toggle-switch::after {
      content: "";
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      top: 1px;
      left: 1px;
      transition: transform var(--transition), background var(--transition);
    }

    .toggle-switch.on {
      border-color: rgba(0, 229, 255, 0.55);
      background: rgba(0, 229, 255, 0.12);
    }

    .toggle-switch.on::after {
      background: var(--accent);
      transform: translateX(18px);
    }

    .filter-section {
      gap: 8px;
    }

    .filter-heading {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .type-filter-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .type-filter-item {
      border-radius: 999px;
      border: 1px solid rgba(80, 120, 140, 0.4);
      padding: 4px 12px;
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: rgba(10, 16, 21, 0.85);
      cursor: pointer;
      transition: border-color var(--transition), background var(--transition), color var(--transition), box-shadow var(--transition);
    }

    .type-filter-item:hover,
    .type-filter-item.active {
      border-color: rgba(0, 229, 255, 0.55);
      background: rgba(0, 229, 255, 0.14);
      box-shadow: 0 8px 24px rgba(0, 229, 255, 0.2);
    }

    .ui-scale-value {
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 0 8px rgba(0, 229, 255, 0.35);
    }

    .ui-scale-slider {
      width: 100%;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(
        90deg,
        var(--accent) 0%,
        var(--accent) var(--slider-fill, 50%),
        rgba(80, 120, 140, 0.35) var(--slider-fill, 50%),
        rgba(80, 120, 140, 0.35) 100%
      );
      border: 1px solid rgba(70, 90, 110, 0.6);
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition);
    }

    .ui-scale-slider:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.45);
    }

    .ui-scale-slider::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.2);
    }

    .ui-scale-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border: none;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.2);
    }

    .ui-scale-slider::-moz-range-track {
      background: transparent;
    }

    .ui-scale-slider::-webkit-slider-runnable-track {
      appearance: none;
      height: 6px;
    }
    .level-controls {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 12px;
      align-items: center;
    }

    .level-button {
      width: 36px;
      aspect-ratio: 1;
      border-radius: 10px;
      border: 1px solid var(--panel-border);
      background: var(--panel);
      color: var(--text);
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      transition: transform var(--transition), border-color var(--transition), background var(--transition);
    }

    .level-button:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--accent);
      background: rgba(0, 229, 255, 0.08);
    }

    .level-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .level-display {
      font-size: 13px;
      color: var(--text-muted);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .level-slider,
    .ui-scale-slider {
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 6px;
      border: 1px solid rgba(70, 90, 110, 0.8);
      --slider-active-fill: var(--slider-fill, 50%);
      background:
        linear-gradient(
          90deg,
          rgba(0, 229, 255, 0.9) 0%,
          rgba(0, 229, 255, 0.9) var(--slider-active-fill),
          rgba(5, 8, 12, 0.95) var(--slider-active-fill),
          rgba(5, 8, 12, 0.95) 100%
        ),
        repeating-linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.08) 0 8px,
          transparent 8px 16px
        ),
        linear-gradient(180deg, rgba(0, 0, 0, 0.45), rgba(255, 255, 255, 0.06)),
        rgba(3, 6, 10, 0.92);
      box-shadow:
        inset 0 0 16px rgba(0, 0, 0, 0.85),
        0 0 14px rgba(0, 229, 255, 0.12);
      cursor: pointer;
      transition: border-color var(--transition), box-shadow var(--transition), background var(--transition);
      position: relative;
    }

    .level-slider {
      --slider-active-fill: var(--level-slider-fill, 0%);
    }

    .ui-scale-slider {
      --slider-active-fill: var(--slider-fill, 50%);
    }

    .level-slider:focus-visible,
    .ui-scale-slider:focus-visible {
      outline: none;
      border-color: rgba(0, 229, 255, 0.8);
      box-shadow:
        0 0 0 1px rgba(0, 229, 255, 0.5),
        0 0 22px rgba(0, 229, 255, 0.35),
        inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    .level-slider::-webkit-slider-thumb,
    .ui-scale-slider::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 18px;
      border-radius: 3px;
      border: 1px solid rgba(0, 229, 255, 0.5);
      background: linear-gradient(180deg, rgba(0, 229, 255, 0.95), rgba(0, 120, 150, 0.85));
      box-shadow:
        0 0 16px rgba(0, 229, 255, 0.35),
        inset 0 0 0 1px rgba(255, 255, 255, 0.25);
      margin-top: -5px;
    }

    .level-slider::-moz-range-thumb,
    .ui-scale-slider::-moz-range-thumb {
      width: 12px;
      height: 18px;
      border-radius: 3px;
      border: 1px solid rgba(0, 229, 255, 0.5);
      background: linear-gradient(180deg, rgba(0, 229, 255, 0.95), rgba(0, 120, 150, 0.85));
      box-shadow:
        0 0 16px rgba(0, 229, 255, 0.35),
        inset 0 0 0 1px rgba(255, 255, 255, 0.25);
    }

    .level-slider::-moz-range-track,
    .ui-scale-slider::-moz-range-track {
      background: transparent;
    }

    .level-slider::-webkit-slider-runnable-track,
    .ui-scale-slider::-webkit-slider-runnable-track {
      appearance: none;
      height: 8px;
    }

    .weapon-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(240px, 280px);
      gap: 22px;
      padding-right: 16px;
      align-items: flex-start;
    }

    .side-column {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-self: stretch;
      width: min(300px);
    }

    .attachments-panel {
      background: rgba(12, 18, 24, 0.55);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      border-radius: 14px;
      border: 1px solid rgba(80, 120, 140, 0.18);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      position: relative;
      overflow: hidden;
      flex: 1;
    }

    .attachments-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(54, 69, 82, 0.35);
      padding-bottom: 12px;
      gap: 12px;
    }

    .attachments-header h2 {
      margin: 0;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(160, 178, 192, 0.9);
    }

    .attachments-separator {
      font-size: 14px;
      color: rgba(160, 178, 192, 0.7);
    }

    .ap-header {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .notes-highlight {
      background: rgba(0, 229, 255, 0.2);
      padding: 0 4px;
      border-radius: 4px;
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.4);
    }

    .notes-color {
      color: var(--accent);
    }

    .ap-readout {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(177, 191, 203, 0.95);
      white-space: nowrap;
    }

    .ap-readout .ap-value {
      color: var(--text);
    }

    .ap-readout .ap-max {
      color: rgba(132, 145, 156, 0.75);
    }

    .ap-readout.ap-overcap .ap-value {
      color: var(--enemy);
    }

    .ap-readout.ap-overcap .ap-max {
      color: rgba(255, 107, 107, 0.9);
    }

    .ap-meter {
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .ap-meter.ap-overcap .ap-cell {
      border-color: rgba(255, 59, 59, 0.6);
      background: rgba(45, 15, 18, 0.9);
      box-shadow: 0 0 8px rgba(255, 59, 59, 0.35);
    }

    .ap-cell {
      position: relative;
      width: 16px;
      height: 16px;
      border-radius: 4px;
      background: rgba(15, 22, 28, 0.92);
      border: 1px solid rgba(41, 54, 65, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background var(--transition), border-color var(--transition), opacity var(--transition);
      overflow: hidden;
    }

    .ap-cell .ap-icon {
      position: relative;
      width: 12px;
      height: 12px;
      display: block;
    }

    .ap-cell .ap-icon img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: grayscale(1) brightness(0.55);
      opacity: 0.4;
      pointer-events: none;
    }

    .ap-meter.ap-overcap .ap-cell .ap-icon img {
      filter: grayscale(0) brightness(1.1);
      opacity: 1;
    }

    .ap-cell.half .ap-icon img,
    .ap-cell.full .ap-icon img {
      filter: grayscale(0.2) brightness(0.9);
      opacity: 0.75;
    }

    .ap-cell.full .ap-icon img {
      opacity: 0.95;
      filter: grayscale(0) brightness(1.05);
    }

    .ap-cell .ap-fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(0, 229, 255, 0.9), rgba(0, 229, 255, 0.65));
      opacity: 0;
      transition: opacity var(--transition);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .ap-meter.ap-overcap .ap-cell .ap-fill {
      background: linear-gradient(135deg, rgba(255, 59, 59, 0.95), rgba(255, 128, 128, 0.75));
    }

    .ap-cell .ap-fill.first {
      clip-path: polygon(0 0, 100% 0, 0 100%);
    }

    .ap-cell .ap-fill.second {
      clip-path: polygon(100% 0, 100% 100%, 0 100%);
    }

    .ap-cell.half {
      background: rgba(22, 30, 37, 0.95);
      border-color: rgba(71, 89, 103, 0.85);
    }

    .ap-cell.half .ap-fill.first {
      opacity: 0.9;
    }

    .ap-cell.full {
      background: rgba(28, 36, 43, 0.95);
      border-color: rgba(96, 110, 122, 0.9);
    }

    .ap-cell.full .ap-fill {
      opacity: 0.95;
    }

    .slots {
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
    }

    .slot-wrapper {
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
    }

    .slot-label {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .slot-card {
      position: relative;
      background: rgba(16, 24, 30, 0.92);
      border-radius: var(--card-radius);
      border: 1px solid rgba(45, 58, 70, 0.7);
      padding: var(--card-padding);
      display: flex;
      flex-direction: column;
      gap: 6px;
      transition: border-color var(--transition), box-shadow var(--transition), background var(--transition), transform var(--transition);
    }

    .slot-card.changed {
      /* Fallbacks for browsers without color-mix */
      border-color: rgba(0, 209, 255, 0.70);
      box-shadow: inset 0 0 0 1px rgba(0, 209, 255, 0.35), 0 10px 28px rgba(0, 209, 255, 0.18);
      /* Preferred modern blend */
      border-color: color-mix(in oklab, var(--ally) 70%, transparent);
      box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--ally) 35%, transparent), 0 10px 28px color-mix(in oklab, var(--ally) 18%, transparent);
      background: rgba(12, 26, 32, 0.92);
    }

    .slot-card.old {
      background: rgba(10, 16, 21, 0.85);
      border-color: rgba(34, 43, 51, 0.9);
      color: var(--text-muted);
    }

    .slot-card.old .card-title {
      text-decoration: line-through;
      text-decoration-color: rgba(255, 255, 255, 0.4);
    }

    .slot-card.removed {
      /* Fallback */
      border-color: rgba(255, 59, 59, 0.60);
      /* Preferred */
      border-color: color-mix(in oklab, var(--enemy) 60%, transparent);
      background: rgba(28, 12, 14, 0.9);
    }

    .slot-card.removed .card-level {
      /* Fallbacks */
      border-color: rgba(255, 59, 59, 0.5);
      color: rgba(255, 120, 120, 0.9);
      /* Preferred */
      border-color: color-mix(in oklab, var(--enemy) 50%, transparent);
      color: color-mix(in oklab, var(--enemy) 65%, white 35%);
    }

    .slot-card.empty {
      font-style: italic;
      color: var(--text-muted);
      border-style: dashed;
    }

    .slot-card.indented {
      margin-left: var(--indent);
    }

    .card-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .card-info {
      display: flex;
      flex-direction: column;
      gap: 3px;
      min-width: 0; /* allow truncation inside flex */
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.02em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .card-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
      font-size: 10px;
      text-transform: uppercase;
      color: rgba(177, 191, 203, 0.78);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .card-meta .meta-type {
      letter-spacing: 0.18em;
      flex: 0 1 auto;
      min-width: 0;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .card-meta .meta-separator {
      opacity: 0.6;
      letter-spacing: 0.18em;
      flex: 0 0 auto;
    }

    .ap-inline {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: rgba(177, 191, 203, 0.9);
      text-transform: uppercase;
      flex: 0 0 auto;
    }

    .ap-inline img {
      width: 9px;
      height: 9px;
      filter: grayscale(1) brightness(0.8);
      opacity: 0.85;
    }

    .slot-card.old .ap-inline {
      opacity: 0.7;
    }

    .card-level {
      margin-left: auto;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(78, 95, 110, 0.6);
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(177, 191, 203, 0.86);
      white-space: nowrap;
    }

    .slot-card.changed .card-level {
      border-color: rgba(0, 229, 255, 0.6);
      background: rgba(0, 229, 255, 0.12);
      color: var(--accent);
    }

    .slot-card.old .card-level {
      border-color: rgba(78, 95, 110, 0.35);
      color: rgba(120, 136, 151, 0.9);
    }

    .card-description {
      font-size: 12px;
      color: rgba(173, 187, 198, 0.85);
      line-height: 1.45;
    }

    .arrow-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .arrow-svg {
      position: absolute;
      overflow: visible;
    }

    .changes-panel {
      background: rgba(16, 24, 30, 0.92);
      border-radius: 12px;
      border: 1px solid rgba(45, 58, 70, 0.7);
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .changes-panel h3 {
      margin: 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    /* Recommended build panel matches changes styling */
    .recommended-panel {
      background: rgba(16, 24, 30, 0.92);
      border-radius: 12px;
      border: 1px solid rgba(45, 58, 70, 0.7);
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .recommended-panel h3 {
      margin: 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .recommended-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .recommended-empty {
      padding: 12px;
      border-radius: 10px;
      border: 1px dashed rgba(60, 74, 85, 0.6);
      color: rgba(148, 161, 173, 0.85);
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
    }

    .change-row {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .change-heading {
      font-size: 12px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(177, 191, 203, 0.9);
    }

    .change-detail {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: rgba(148, 161, 173, 0.85);
    }

    .change-detail .change-next {
      color: var(--accent);
    }

    .changes-empty {
      padding: 12px;
      border-radius: 10px;
      border: 1px dashed rgba(60, 74, 85, 0.6);
      color: rgba(148, 161, 173, 0.85);
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
    }

    @media (max-width: 960px) {
      .weapon-layout {
        grid-template-columns: 1fr;
      }

      .side-column {
        width: 100%;
      }
    }

    @media (max-width: 720px) {
      body {
        padding: 16px;
      }

      .app {
        padding: 20px;
      }
    }

    /* Layout fix: keep side column within right grid track on wide screens */
    @media (min-width: 960px) {
      .side-column { width: 100%; max-width: 280px; }
    }
  /* Enhanced chip visuals (vibrant + glow) */
    @keyframes chipGlowPulse {
      0%,
      100% {
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3), 0 0 0 var(--chip-glow-color, rgba(255, 255, 255, 0.2));
      }
      50% {
        box-shadow: 0 0 14px var(--chip-glow-color, rgba(255, 255, 255, 0.35)),
          0 0 var(--chip-glow-spread, 26px) var(--chip-glow-color, rgba(255, 255, 255, 0.35));
      }
    }

    @keyframes chipHueDrift {
      0% {
        background-position: 0% 0%;
      }
      50% {
        background-position: 70% 80%;
      }
      100% {
        background-position: 0% 0%;
      }
    }

    @keyframes metaFireFlow {
      0% {
        background-position: 0% 20%;
      }
      50% {
        background-position: 80% 90%;
      }
      100% {
        background-position: 0% 20%;
      }
    }

    @keyframes metaFirePlume {
      0% {
        transform: scale(0.9) translate(-6%, 6%);
        opacity: 0.4;
      }
      50% {
        transform: scale(1.05) translate(4%, -3%);
        opacity: 0.85;
      }
      100% {
        transform: scale(0.95) translate(-4%, 4%);
        opacity: 0.45;
      }
    }

    @keyframes metaSparkDrift {
      0% {
        background-position:
          25% 95%,
          65% 55%,
          0% 0%;
      }
      50% {
        background-position:
          45% 75%,
          55% 35%,
          30% 20%;
      }
      100% {
        background-position:
          20% 90%,
          75% 60%,
          60% 10%;
      }
    }

    @keyframes metaFlameClip {
      0% {
        clip-path: polygon(6% 100%, 14% 58%, 22% 86%, 32% 20%, 42% 78%, 54% 10%, 66% 74%, 78% 18%, 90% 84%, 100% 32%, 100% 100%, 0% 100%);
      }
      50% {
        clip-path: polygon(6% 100%, 16% 68%, 26% 46%, 34% 8%, 46% 64%, 58% 6%, 70% 58%, 84% 10%, 94% 70%, 100% 24%, 100% 100%, 0% 100%);
      }
      100% {
        clip-path: polygon(6% 100%, 12% 55%, 22% 82%, 34% 18%, 46% 72%, 58% 14%, 70% 80%, 84% 26%, 94% 86%, 100% 38%, 100% 100%, 0% 100%);
      }
    }

    @keyframes metaFlameRise {
      0% {
        transform: translateY(1px) scaleY(0.92);
        opacity: 0.9;
      }
      50% {
        transform: translateY(-2px) scaleY(1.08);
        opacity: 1;
      }
      100% {
        transform: translateY(1px) scaleY(0.94);
        opacity: 0.9;
      }
    }

    @keyframes metaFlameTexture {
      0% {
        background-position:
          50% 0%,
          50% 100%,
          0% 110%;
        opacity: 0.85;
      }
      50% {
        background-position:
          52% 15%,
          48% 80%,
          10% 60%;
        opacity: 1;
      }
      100% {
        background-position:
          46% -10%,
          52% 120%,
          -10% 90%;
        opacity: 0.9;
      }
    }

    @keyframes chipShimmer {
      0% {
        opacity: 0;
        transform: translateX(-130%) rotate(12deg);
      }
      40% {
        opacity: var(--range-shimmer-opacity, 0.35);
      }
      60% {
        opacity: var(--range-shimmer-opacity, 0.35);
      }
      100% {
        opacity: 0;
        transform: translateX(130%) rotate(12deg);
      }
    }


    @keyframes metaCorePulse {
      0%,
      100% {
        transform: scaleY(0.96);
        filter: saturate(1) brightness(1);
      }
      45% {
        transform: scaleY(1.05);
        filter: saturate(1.25) brightness(1.08);
      }
      75% {
        transform: scaleY(1.02);
        filter: saturate(1.15) brightness(1.04);
      }
    }

    .meta-chip.type-chip {
      background: linear-gradient(135deg, rgba(0, 229, 255, 0.24), rgba(0, 229, 255, 0.1));
      border-color: rgba(0, 229, 255, 0.65);
      color: #fff;
      --chip-text-glow: 0 0 8px rgba(0, 229, 255, 0.55);
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.25), inset 0 0 6px rgba(0, 229, 255, 0.25);
    }

    .meta-chip.rank-m {
      background-image:
        radial-gradient(circle at 18% 32%, rgba(255, 255, 255, 0.4), transparent 52%),
        radial-gradient(circle at 78% 22%, rgba(255, 190, 90, 0.45), transparent 62%),
        conic-gradient(from 10deg, rgba(255, 210, 140, 0.25), rgba(255, 110, 0, 0.4), rgba(255, 210, 140, 0.25)),
        linear-gradient(140deg, #ffb347 0%, #ff6a00 45%, #a10d00 90%);
      background-size: 170% 170%, 200% 200%, 320% 320%, 230% 230%;
      background-position: 0% 20%, 60% 30%, 0% 0%, 0% 0%;
      background-blend-mode: screen, screen, screen, normal;
      border-color: rgba(255, 166, 43, 0.95);
      color: #fff;
      --chip-text-glow: 0 0 12px rgba(255, 182, 70, 0.95);
      --chip-glow-color: rgba(255, 139, 51, 0.92);
      --chip-glow-spread: 52px;
      --chip-glow-speed: 1.7s;
      box-shadow:
        0 0 16px rgba(255, 140, 40, 0.65),
        0 0 36px rgba(255, 90, 0, 0.4),
        inset 0 0 18px rgba(255, 200, 125, 0.4);
      filter: drop-shadow(0 0 8px rgba(255, 120, 32, 0.55));
      transform-origin: center;
      animation:
        metaFireFlow 4.6s linear infinite,
        chipGlowPulse var(--chip-glow-speed) ease-in-out infinite,
        metaCorePulse 2.3s ease-in-out infinite;
    }

    .meta-chip.rank-m::before {
      content: "";
      position: absolute;
      inset: -44% -18%;
      border-radius: 50%;
      background-image:
        radial-gradient(circle at 20% 95%, rgba(255, 255, 255, 0.55), transparent 52%),
        radial-gradient(circle at 68% 58%, rgba(255, 128, 0, 0.65), transparent 72%),
        radial-gradient(circle at 45% 25%, rgba(255, 210, 120, 0.35), transparent 65%),
        repeating-conic-gradient(from 0deg, rgba(255, 220, 120, 0.2) 0deg 16deg, transparent 16deg 32deg);
      background-size: 220% 220%, 210% 210%, 160% 190%, 380% 380%;
      background-position: 20% 100%, 65% 55%, 44% 32%, 0% 0%;
      background-blend-mode: screen;
      mix-blend-mode: screen;
      filter: blur(1.6px);
      opacity: 0.8;
      pointer-events: none;
      animation: metaFirePlume 3s ease-in-out infinite, metaSparkDrift 10s linear infinite;
      z-index: -2;
    }

    .meta-chip.rank-m::after {
      content: "";
      position: absolute;
      inset: -12px 4px 4px;
      background-image:
        radial-gradient(circle at 52% -5%, rgba(255, 255, 255, 0.92), transparent 62%),
        linear-gradient(180deg, rgba(255, 240, 210, 0.98) 0%, rgba(255, 190, 70, 0.9) 38%, rgba(255, 106, 0, 0.82) 78%, rgba(80, 10, 0, 0)),
        repeating-linear-gradient(180deg, rgba(255, 221, 173, 0.5) 0 12px, rgba(255, 114, 0, 0.2) 12px 24px),
        radial-gradient(circle at 28% 90%, rgba(255, 220, 140, 0.55), transparent 55%);
      background-blend-mode: screen;
      background-size:
        150% 170%,
        100% 125%,
        90% 240%,
        170% 210%;
      background-position:
        52% 0%,
        50% 100%,
        0% 110%,
        36% 78%;
      clip-path: polygon(6% 100%, 14% 58%, 22% 86%, 32% 22%, 42% 78%, 54% 12%, 66% 74%, 78% 18%, 90% 84%, 100% 32%, 100% 100%, 0% 100%);
      mix-blend-mode: screen;
      filter: blur(0.6px) drop-shadow(0 0 6px rgba(255, 150, 60, 0.5));
      opacity: 0.98;
      pointer-events: none;
      animation: metaFlameRise 1.6s ease-in-out infinite, metaFlameClip 1.6s ease-in-out infinite, metaFlameTexture 1.25s linear infinite;
      z-index: -1;
    }

    .meta-chip.rank-a {
      background: linear-gradient(135deg, #6ee5ff 0%, #00b0ff 45%, #0e1c40 100%);
      background-size: 220% 220%;
      border-color: rgba(0, 191, 255, 0.82);
      color: #fff;
      --chip-text-glow: 0 0 8px rgba(103, 229, 255, 0.75);
      --chip-glow-color: rgba(63, 200, 255, 0.6);
      --chip-glow-spread: 32px;
      --chip-glow-speed: 2.4s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 9s linear infinite;
    }

    .meta-chip.rank-b {
      background: linear-gradient(135deg, #64f2b0 0%, #14d672 55%, #092017 100%);
      background-size: 200% 200%;
      border-color: rgba(20, 214, 114, 0.78);
      color: #fff;
      --chip-text-glow: 0 0 6px rgba(77, 230, 155, 0.65);
      --chip-glow-color: rgba(26, 196, 124, 0.5);
      --chip-glow-spread: 28px;
      --chip-glow-speed: 2.8s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 11s linear infinite;
    }

    .meta-chip.rank-c {
      background: linear-gradient(135deg, #ffd08f 0%, #ff9b4d 60%, #341608 100%);
      background-size: 190% 190%;
      border-color: rgba(255, 155, 77, 0.75);
      color: #fff;
      --chip-text-glow: 0 0 5px rgba(255, 166, 96, 0.5);
      --chip-glow-color: rgba(255, 171, 92, 0.45);
      --chip-glow-spread: 24px;
      --chip-glow-speed: 3.2s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 13s linear infinite;
    }

    .meta-chip.rank-d {
      background: linear-gradient(135deg, #ffafaf 0%, #ff5c5c 60%, #2b0a0f 100%);
      background-size: 180% 180%;
      border-color: rgba(255, 92, 92, 0.7);
      color: #fff;
      --chip-text-glow: 0 0 4px rgba(255, 118, 118, 0.45);
      --chip-glow-color: rgba(255, 102, 102, 0.35);
      --chip-glow-spread: 22px;
      --chip-glow-speed: 3.6s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 16s linear infinite;
    }

    .meta-chip.rank-unranked {
      background: linear-gradient(135deg, #b59aff 0%, #6a4dff 65%, #1e103c 100%);
      background-size: 210% 210%;
      border-color: rgba(125, 95, 255, 0.72);
      color: #fff;
      --chip-text-glow: 0 0 6px rgba(160, 135, 255, 0.55);
      --chip-glow-color: rgba(125, 95, 255, 0.4);
      --chip-glow-spread: 26px;
      --chip-glow-speed: 4.2s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 18s linear infinite;
    }

    /* Type rating (TR) chips: #1 gold, #2 silver, #3 bronze, #4 dull blue */
    .meta-chip.range-1,
    .meta-chip.range-2,
    .meta-chip.range-3,
    .meta-chip.range-4,
    .meta-chip.range-unranked {
      background-size: 220% 220%;
    }

    .meta-chip.range-1 {
      background: linear-gradient(135deg, #ffe57a 0%, #f7c148 45%, #7c4200 100%);
      border-color: rgba(241, 196, 15, 0.85);
      color: #fff;
      --chip-text-glow: 0 0 8px rgba(241, 196, 15, 0.65);
      --chip-glow-color: rgba(255, 214, 130, 0.75);
      --chip-glow-spread: 32px;
      --chip-glow-speed: 2.3s;
      --range-shimmer-color: rgba(255, 249, 220, 0.95);
      --range-shimmer-opacity: 0.95;
      --range-shimmer-speed: 3s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 10s linear infinite;
    }

    .meta-chip.range-2 {
      background: linear-gradient(135deg, #f0f4f8 0%, #bfc7cc 55%, #3b4750 100%);
      border-color: rgba(191, 199, 204, 0.85);
      color: #fff;
      --chip-text-glow: 0 0 7px rgba(191, 199, 204, 0.55);
      --chip-glow-color: rgba(221, 232, 239, 0.55);
      --chip-glow-spread: 28px;
      --chip-glow-speed: 2.9s;
      --range-shimmer-color: rgba(255, 255, 255, 0.85);
      --range-shimmer-opacity: 0.65;
      --range-shimmer-speed: 4s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 12s linear infinite;
    }

    .meta-chip.range-3 {
      background: linear-gradient(135deg, #f3b26e 0%, #cd7f32 60%, #3a1a08 100%);
      border-color: rgba(205, 127, 50, 0.8);
      color: #fff;
      --chip-text-glow: 0 0 6px rgba(205, 127, 50, 0.45);
      --chip-glow-color: rgba(205, 127, 50, 0.45);
      --chip-glow-spread: 24px;
      --chip-glow-speed: 3.4s;
      --range-shimmer-color: rgba(255, 213, 170, 0.65);
      --range-shimmer-opacity: 0.45;
      --range-shimmer-speed: 5s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 14s linear infinite;
    }

    .meta-chip.range-4 {
      background: linear-gradient(135deg, #7c96ab 0%, #4a6273 65%, #101820 100%);
      border-color: rgba(91, 122, 142, 0.75);
      color: #fff;
      --chip-text-glow: 0 0 5px rgba(91, 122, 142, 0.45);
      --chip-glow-color: rgba(112, 142, 162, 0.32);
      --chip-glow-spread: 20px;
      --chip-glow-speed: 4.1s;
      --range-shimmer-color: rgba(255, 255, 255, 0.4);
      --range-shimmer-opacity: 0.2;
      --range-shimmer-speed: 6.2s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 18s linear infinite;
    }

    .meta-chip.range-unranked {
      background: linear-gradient(135deg, #b59aff 0%, #6a4dff 70%, #1e103c 100%);
      border-color: rgba(125, 95, 255, 0.7);
      color: #fff;
      --chip-text-glow: 0 0 6px rgba(125, 95, 255, 0.55);
      --chip-glow-color: rgba(125, 95, 255, 0.35);
      --chip-glow-spread: 22px;
      --chip-glow-speed: 4.8s;
      --range-shimmer-color: rgba(200, 180, 255, 0.45);
      --range-shimmer-opacity: 0.25;
      --range-shimmer-speed: 7s;
      animation: chipGlowPulse var(--chip-glow-speed) ease-in-out infinite, chipHueDrift 20s linear infinite;
    }

    .meta-chip.range-1::after,
    .meta-chip.range-2::after,
    .meta-chip.range-3::after,
    .meta-chip.range-4::after,
    .meta-chip.range-unranked::after {
      content: "";
      position: absolute;
      inset: -45% -15%;
      border-radius: inherit;
      background: linear-gradient(115deg, transparent 20%, var(--range-shimmer-color, rgba(255, 255, 255, 0.4)) 50%, transparent 80%);
      opacity: 0;
      transform: translateX(-130%) rotate(12deg);
      animation: chipShimmer var(--range-shimmer-speed, 6s) ease-in-out infinite;
      mix-blend-mode: screen;
      z-index: -1;
    }
</style>
</head>
<body>
  <div class="layout-grid">
    <nav id="weaponNav" class="side-nav" aria-label="Weapons"></nav>
    <div class="app-shell">
      <div class="app">
        <header class="page-header">
          <h1 class="page-title">Mastery Loadout Tracker</h1>
          <p class="page-subtitle">Track multiple mastery weapons, compare their attachment unlocks, and keep your favorites pinned for fast reference.</p>
        </header>
        <div class="weapon-list" id="weaponList"></div>
      </div>
    </div>
    <section class="options-panel ui-scale-panel" id="uiScalePanel" role="region" aria-label="Options">
      <div class="options-header">
        <span class="options-title">Options</span>
        <button class="options-gear" id="optionsGearButton" type="button" aria-expanded="true" aria-controls="optionsBody" aria-label="Hide options">
          <span aria-hidden="true" class="gear-symbol"></span>
          <span class="sr-only">Toggle options</span>
        </button>
      </div>
      <div class="options-body" id="optionsBody">
        <div class="option-card ui-scale-card">
          <div class="ui-scale-heading">
            <span class="option-heading">UI Scale</span>
            <output class="ui-scale-value" id="uiScaleValue" for="uiScaleSlider">100%</output>
          </div>
          <input type="range" class="ui-scale-slider" id="uiScaleSlider" min="50" max="200" step="5" value="100" aria-label="UI scale" />
        </div>
        <button class="option-card options-toggle" type="button" id="reduceAnimationsToggle" aria-pressed="false">
          <span class="option-heading">Reduce Animations</span>
          <span class="toggle-switch" aria-hidden="true"></span>
        </button>
        <div class="filter-section option-card">
          <div class="filter-heading">Filter by Type</div>
          <div class="type-filter-list" id="typeFilterList" role="tablist"></div>
        </div>
      </div>
    </section>
  </div>
  <button class="options-floating-gear" id="optionsFloatingButton" type="button" aria-label="Show options" hidden>
    <span class="sr-only">Show options</span>
    <span aria-hidden="true" class="gear-symbol"></span>
  </button>
  <template id="weaponTemplate">
    <section class="weapon-card" tabindex="0">
      <div class="weapon-header" draggable="true">
        <button class="drag-handle" type="button" title="Drag to reorder" aria-label="Drag to reorder" draggable="true">
          <span aria-hidden="true">&#9776;</span>
        </button>
        <div class="control-stack">
          <button class="collapse-box" type="button" aria-label="Toggle collapse" aria-expanded="true">&#9662;</button>
          <button class="favorite-toggle" type="button" aria-pressed="false" title="Toggle favorite">
            <span aria-hidden="true">&#9734;</span>
          </button>
        </div>
        <div class="weapon-header-text" tabindex="0" role="button" aria-label="Toggle collapse" aria-expanded="true">
          <div class="weapon-name"></div>          <div class="weapon-meta-row"><span class="meta-chip type-chip"></span><span class="meta-chip rank-chip"></span><span class="meta-chip range-chip"></span></div>
          
          <div class="header-controls">
            <span class="header-level" aria-live="polite">LEVEL 1</span>
            <span class="header-sep" aria-hidden="true">&bull;</span>
            <button class="level-button level-down" type="button" aria-label="Decrease level">-</button>
            <input class="level-slider" type="range" min="1" max="40" step="1" value="1" aria-label="Set level">
            <button class="level-button level-up" type="button" aria-label="Increase level">+</button>
          </div>
        </div>
        <div class="weapon-image-wrap placeholder">
          <img class="weapon-image" alt="" loading="lazy" draggable="false" />
          <div class="weapon-image-ph">No Image Yet</div>
        </div>
        <div class="level-pill"></div>
        <button class="collapse-toggle" type="button" aria-expanded="true">Hide</button>
      </div>
      <div class="weapon-body">
        <div class="level-display"></div>
        <div class="build-tabs" hidden>
          <div class="build-tablist" role="tablist"></div>
        </div>
        <div class="weapon-layout">
          <section class="attachments-panel">
          <div class="attachments-header">
            <h2>Attachments</h2>
            <div class="ap-header">
              <div class="ap-meter"></div>
              <div class="ap-readout">
                <span class="ap-value"></span>
                <span class="ap-max"></span>
              </div>
            </div>
            </div>
            <div class="slots"></div>
          </section>
          <aside class="side-column">
            <section class="changes-panel">
              <h3>Changes at this Level</h3>
              <div class="changes-empty">No changes unlocked at this level.</div>
            </section>
            <section class="recommended-panel" hidden>
              <h3>Recommended Build</h3>
              <div class="ap-total ap-total-recommended">
              <div class="ap-meter"></div>
              <div class="ap-readout">
                <span class="ap-value"></span>
                <span class="ap-max"></span>
              </div>
              </div>
              <div class="recommended-list"></div>
            </section>
          </aside>
        </div>
      </div>
    </section>
  </template>
  <script src="weapon-db.js"></script>
  <script src="manualbuilds.js"></script>
  <script>
    const AP_ICON = 'https://static.wikia.nocookie.net/battlefield/images/0/06/Battlefield_6_Attachment_Point_Icon.png';
    const INDENT = 36;
    const CARD_PAD = 12;
    const ARROW_STROKE = 3;

    document.documentElement.style.setProperty('--indent', `${INDENT}px`);
    document.documentElement.style.setProperty('--card-padding', `${CARD_PAD}px`);

    const toUpperSafe = (value) => (typeof value === 'string' ? value.toUpperCase() : value);
    function formatTypeKey(value) {
      return typeof value === 'string' ? value.trim().toUpperCase() : '';
    }

    const TYPE_ORDER = [
      'ASSAULT RIFLE',
      'CARBINE',
      'DMR',
      'LMG',
      'SMG',
      'SHOTGUN',
      'SNIPER',
      'SECONDARY',
      'PISTOL',
      'LAUNCHER'
    ];
    const TYPE_INDEX = TYPE_ORDER.reduce((map, type, index) => {
      map[type] = index;
      return map;
    }, {});

    const attachmentDatabase =
      typeof window !== 'undefined' && window.weaponDatabase && typeof window.weaponDatabase === 'object'
        ? window.weaponDatabase
        : {};
    const typeFilterList =
      typeof document !== 'undefined' ? document.getElementById('typeFilterList') : null;
    const TYPE_FILTER_KEY = 'bf6-meta-type-filter';
    const FAVORITES_FILTER = 'FAVORITES';
    const ACTIVE_TAB_STORAGE_KEY = 'bf6-meta-active-tab';
    let currentTypeFilter = formatTypeKey(loadTypeFilter());
    const activeTabMap = loadActiveTabs();

    const normalizeDbKey = (value) => (typeof value === 'string' ? value.trim().toUpperCase() : '');

    function getWeaponDb(dbName) {
      if (!dbName || typeof dbName !== 'string') return null;
      const trimmed = dbName.trim();
      if (!trimmed) return null;
      return (
        attachmentDatabase[trimmed] ||
        attachmentDatabase[normalizeDbKey(trimmed)] ||
        attachmentDatabase[trimmed.toLowerCase()] ||
        null
      );
    }

    const attachmentIndexCache = new WeakMap();

    function getAttachmentIndex(attachments) {
      if (!attachments || typeof attachments !== 'object') return null;
      let cache = attachmentIndexCache.get(attachments);
      if (cache) return cache;
      cache = new Map();
      for (const [name, data] of Object.entries(attachments)) {
        const normalized = normalizeDbKey(name);
        if (!normalized || cache.has(normalized)) continue;
        cache.set(normalized, data);
      }
      attachmentIndexCache.set(attachments, cache);
      return cache;
    }

    function resolveAttachmentFromDb(dbName, attachmentName) {
      if (!dbName || !attachmentName) return null;
      const db = getWeaponDb(dbName);
      if (!db || typeof db !== 'object') return null;
      const attachments = db.attachments || {};
      const key = normalizeDbKey(attachmentName);
      let raw = null;
      if (key) {
        const index = getAttachmentIndex(attachments);
        if (index && index.has(key)) {
          raw = index.get(key);
        } else if (attachments[key]) {
          raw = attachments[key];
        }
      }
      if (!raw && typeof attachmentName === 'string' && attachments[attachmentName]) {
        raw = attachments[attachmentName];
      }
      if (!raw) return null;
      const copy = { ...raw };
      if (!copy.name) {
        copy.name = key || attachmentName;
      }
      return copy;
    }

    function normalizeReplaced(replaced, dbName) {
      if (!replaced) return [];
      const array = Array.isArray(replaced) ? replaced : [replaced];
      return array
        .map((entry) => {
          if (typeof entry === 'string') {
            const lookup = resolveAttachmentFromDb(dbName, entry);
            const normalized = lookup ? { ...lookup } : { name: entry };
            if (normalized.name) normalized.name = toUpperSafe(normalized.name);
            if (normalized.type) normalized.type = toUpperSafe(normalized.type);
            return normalized;
          }
          if (entry && typeof entry === 'object') {
            const lookup = entry.name ? resolveAttachmentFromDb(dbName, entry.name) : null;
            const normalized = { ...(lookup || {}), ...entry };
            if (normalized.name) normalized.name = toUpperSafe(normalized.name);
            if (normalized.type) normalized.type = toUpperSafe(normalized.type);
            return normalized;
          }
          return null;
        })
        .filter(Boolean);
    }

    function normalizeEntry(payload, unlockLevel, dbName) {
      if (payload == null) return null;
      const isString = typeof payload === 'string';
      if (!isString && typeof payload !== 'object') return null;
      const baseName = isString
        ? payload
        : typeof payload.name === 'string'
        ? payload.name
        : null;
      const lookup = baseName ? resolveAttachmentFromDb(dbName, baseName) : null;
      const source = lookup ? { ...lookup } : {};
      const overrides = isString ? { name: payload } : { ...payload };
      const entry = { ...source, ...overrides };
      if (!entry.name && baseName) {
        entry.name = baseName;
      }
      if (unlockLevel !== undefined) {
        entry.unlockLevel = unlockLevel;
      } else if (entry.unlockLevel === undefined && source.unlockLevel !== undefined) {
        entry.unlockLevel = source.unlockLevel;
      }
      if (entry.name) entry.name = toUpperSafe(entry.name);
      if (entry.type) entry.type = toUpperSafe(entry.type);
      if (entry.replaced) {
        entry.replaced = normalizeReplaced(entry.replaced, dbName);
      }
      return entry;
    }

    const SLOT_KEY_BY_TYPE = {
      BARREL: '1',
      UNDERBARREL: '2',
      AMMUNITION: '3',
      MUZZLE: '4',
      'RIGHT ACCESSORY': '5',
      MAGAZINE: '6',
      SCOPE: '7',
      'LEFT ACCESSORY': '8',
      'TOP ACCESSORY': '9',
      'OPTIC ACCESSORY': '10',
      ERGONOMICS: '11'
    };

    function getTypeFromPayload(payload, dbName) {
      if (payload && typeof payload === 'object' && typeof payload.type === 'string') {
        return payload.type;
      }
      const baseName =
        typeof payload === 'string'
          ? payload
        : payload && typeof payload.name === 'string'
          ? payload.name
          : payload && typeof payload.remove === 'string'
          ? payload.remove
          : null;
      if (!baseName || !dbName) return null;
      const lookup = resolveAttachmentFromDb(dbName, baseName);
      return lookup && lookup.type ? lookup.type : null;
    }

    function normalizeSlotKeyFromPayload(payload, dbName) {
      if (payload && typeof payload === 'object') {
        if (payload.slot !== undefined && payload.slot !== null) return String(payload.slot);
        if (payload.slotKey !== undefined && payload.slotKey !== null) return String(payload.slotKey);
        if (payload.slotName) return String(payload.slotName);
      }
      const type = getTypeFromPayload(payload, dbName);
      if (!type) return null;
      const normalized = type.toString().trim().toUpperCase();
      return SLOT_KEY_BY_TYPE[normalized] || normalized;
    }

    function sanitizePayloadForStorage(payload) {
      if (!payload || typeof payload !== 'object') return payload;
      const copy = { ...payload };
      delete copy.slot;
      delete copy.slotKey;
      delete copy.slotName;
      delete copy.slotId;
      delete copy.remove;
      delete copy.removed;
      delete copy.action;
      return copy;
    }

    function isRemovalPayload(payload) {
      if (!payload || typeof payload !== 'object') return false;
      if (payload.remove === true || payload.removed === true) return true;
      if (typeof payload.remove === 'string' && payload.remove.trim()) return true;
      if (typeof payload.action === 'string' && payload.action.trim().toLowerCase() === 'remove') {
        return true;
      }
      return false;
    }

    function normalizeBaselineConfig(raw, dbName) {
      if (!raw) return {};
      if (Array.isArray(raw)) {
        const map = {};
        for (const entry of raw) {
          if (entry == null) continue;
          const slotKey = normalizeSlotKeyFromPayload(entry, dbName);
          if (!slotKey) continue;
          map[slotKey] = sanitizePayloadForStorage(entry);
        }
        return map;
      }
      return typeof raw === 'object' ? raw : {};
    }

    function normalizeChangesConfig(raw, dbName) {
      if (!raw || typeof raw !== 'object') return raw || {};
      const normalized = {};
      for (const [level, definition] of Object.entries(raw)) {
        if (Array.isArray(definition)) {
          const map = {};
          for (const entry of definition) {
            if (entry == null) continue;
            const slotKey = normalizeSlotKeyFromPayload(entry, dbName);
            if (!slotKey) continue;
            if (isRemovalPayload(entry)) {
              map[slotKey] = null;
            } else {
              map[slotKey] = sanitizePayloadForStorage(entry);
            }
          }
          normalized[level] = map;
        } else {
          normalized[level] = definition;
        }
      }
      return normalized;
    }

    const storage = (() => {
      const KEY = 'bf6-meta-state-v2';
      const store = typeof window !== 'undefined' && window.localStorage ? window.localStorage : null;
      let data = { weapons: {}, order: [] };

      const raw = store ? store.getItem(KEY) : null;
      const sanitized = typeof raw === 'string' ? raw.trim() : '';
      if (sanitized && (sanitized.startsWith('{') || sanitized.startsWith('['))) {
        const parsed = JSON.parse(sanitized);
        if (parsed && typeof parsed === 'object') {
          data = {
            weapons: parsed.weapons && typeof parsed.weapons === 'object' ? parsed.weapons : {},
            order: Array.isArray(parsed.order) ? parsed.order : []
          };
        }
      }

      function save() {
        if (!store) return;
        store.setItem(KEY, JSON.stringify(data));
      }

      function ensureWeapon(id) {
        if (!data.weapons[id]) {
          data.weapons[id] = {};
          save();
        }
      }

      return {
        getWeaponState(id) {
          ensureWeapon(id);
          return { ...data.weapons[id] };
        },
        updateWeaponState(id, patch) {
          ensureWeapon(id);
          data.weapons[id] = { ...data.weapons[id], ...patch };
          save();
        },
        getOrder() {
          return Array.isArray(data.order) ? [...data.order] : [];
        },
        setOrder(order) {
          if (!Array.isArray(order)) return;
          data.order = [...order];
          save();
        }
      };
    })();

    let currentDraggedId = null;
    let cardDropPlaceholder = null;
    let navDropPlaceholder = null;
    let dragActive = false;

    function getCardDropPlaceholder() {
      if (!cardDropPlaceholder) {
        cardDropPlaceholder = document.createElement('div');
        cardDropPlaceholder.className = 'weapon-drop-placeholder';
        cardDropPlaceholder.setAttribute('aria-hidden', 'true');
        cardDropPlaceholder.textContent = 'Drop weapon here';
      }
      return cardDropPlaceholder;
    }

    function clearCardDropPlaceholder() {
      if (cardDropPlaceholder && cardDropPlaceholder.parentNode) {
        cardDropPlaceholder.parentNode.removeChild(cardDropPlaceholder);
      }
    }

    function getNavDropPlaceholder() {
      if (!navDropPlaceholder) {
        navDropPlaceholder = document.createElement('li');
        navDropPlaceholder.className = 'side-nav-item nav-drop-placeholder';
        navDropPlaceholder.setAttribute('aria-hidden', 'true');
        navDropPlaceholder.textContent = 'Drop weapon here';
        navDropPlaceholder.draggable = false;
      }
      return navDropPlaceholder;
    }

    function clearNavDropPlaceholder() {
      if (navDropPlaceholder && navDropPlaceholder.parentNode) {
        navDropPlaceholder.parentNode.removeChild(navDropPlaceholder);
      }
    }

    function setDragActiveState(active) {
      if (dragActive === active) return;
      dragActive = active;
      document.body.classList.toggle('drag-active', active);
    }

    function enableNavDrag(item) {
      if (!item) return;
      item.setAttribute('draggable', 'true');
      item.addEventListener('dragstart', handleNavItemDragStart);
      item.addEventListener('dragend', handleNavItemDragEnd);
    }

    function handleNavItemDragStart(event) {
      const item = event.currentTarget;
      if (!item) return;
      const id = item.dataset.weaponId;
      if (!id) return;
      currentDraggedId = id;
      setDragActiveState(true);
      item.classList.add('dragging');
      if (event.dataTransfer) {
        event.dataTransfer.effectAllowed = 'move';
        try {
          event.dataTransfer.setData('text/plain', id);
        } catch (_) {}
      }
    }

    function handleNavItemDragEnd(event) {
      const item = event && event.currentTarget;
      if (item) item.classList.remove('dragging');
      clearNavDropPlaceholder();
      clearCardDropPlaceholder();
      currentDraggedId = null;
      setDragActiveState(false);
    }

    class WeaponTracker {
      constructor(config) {
        this.config = config;
        this.id = config.id;
        this.minLevel = Number.isFinite(config.minLevel) ? config.minLevel : 1;
        this.dbname =
          typeof config.dbname === 'string' && config.dbname.trim()
            ? config.dbname.trim()
            : null;
        this.dbEntry = this.dbname ? getWeaponDb(this.dbname) : null;
        const meta = this.dbEntry && typeof this.dbEntry === 'object' ? this.dbEntry : null;
        const configName = typeof config.name === 'string' ? config.name.trim() : '';
        const configType = typeof config.type === 'string' ? config.type.trim() : '';
        const configImage = typeof config.image === 'string' ? config.image.trim() : '';
        const metaName = meta && typeof meta.name === 'string' ? meta.name.trim() : '';
        const metaType = meta && typeof meta.type === 'string' ? meta.type.trim() : '';
        const metaImage = meta && typeof meta.image === 'string' ? meta.image.trim() : '';
        const metaMaxLevel = meta && Number.isFinite(meta.maxLevel) ? meta.maxLevel : null;
        const metaApMax = meta && Number.isFinite(meta.apMax) ? meta.apMax : null;
        this.displayName = configName || metaName || this.id;
        this.displayType = configType || metaType || '';
        this.displayImage = configImage || metaImage || '';
        this.typeKey = formatTypeKey(this.displayType || '');
        const trCode = (config.tr || '').toString().trim();
        const trValue = parseInt(trCode, 10);
        this.typeRatingValue = Number.isFinite(trValue) ? trValue : Number.MAX_SAFE_INTEGER;
        this.maxLevel = Number.isFinite(config.maxLevel)
          ? config.maxLevel
          : Number.isFinite(metaMaxLevel)
          ? metaMaxLevel
          : 40;
        this.apMax = Number.isFinite(config.apMax)
          ? config.apMax
          : Number.isFinite(metaApMax)
          ? metaApMax
          : 100;
        this.slotLabels = { ...(config.slotLabels || {}) };
        for (const key of Object.keys(this.slotLabels)) {
          this.slotLabels[key] = toUpperSafe(this.slotLabels[key]);
        }
        this.baseline = normalizeBaselineConfig(config.baseline, this.dbname);
        this.changes = normalizeChangesConfig(config.changes, this.dbname);
        this.slotKeys = this.buildSlotKeys();
        this.buildDefinitions = this.resolveBuildDefinitions();
        this.buildById = this.buildDefinitions.reduce((map, build) => {
          map[build.id] = build;
          return map;
        }, {});
        this.activeBuildId = this.buildDefinitions.length ? this.buildDefinitions[0].id : null;
        const savedTab = activeTabMap[this.id];
        if (savedTab && this.buildById[savedTab]) {
          this.activeBuildId = savedTab;
        }
        this.activeBuildNote = null;
        this.activeBuildApStats = null;

        const saved = storage.getWeaponState(this.id);
        const defaultLevel = Number.isFinite(config.initialLevel) ? config.initialLevel : this.minLevel;
        this.state = {
          level: this.clampLevel(Number.isFinite(saved.level) ? saved.level : defaultLevel),
          collapsed: Boolean(saved.collapsed),
          favorite: Boolean(saved.favorite)
        };

        this.arrowLayerEl = document.createElement('div');
        this.arrowLayerEl.className = 'arrow-layer';
      }

      resolveSlotType(payload) {
        if (!payload) return undefined;
        if (typeof payload === 'string') {
          const match = resolveAttachmentFromDb(this.dbname, payload);
          return match && match.type ? match.type : undefined;
        }
        if (payload.type) return payload.type;
        if (payload.name) {
          const match = resolveAttachmentFromDb(this.dbname, payload.name);
          if (match && match.type) return match.type;
        }
        return undefined;
      }

      buildSlotKeys() {
        const manualOrder = Array.isArray(this.config.slotOrder) ? this.config.slotOrder.map((slot) => String(slot)) : [];
        const manualIndex = new Map();
        manualOrder.forEach((slot, idx) => manualIndex.set(String(slot), idx));
        const firstSeen = new Map();
        let serial = 0;

        const recordSlot = (slot, label, levelHint, opts = {}) => {
          if (slot === undefined || slot === null) return;
          const key = String(slot);
          if (label && !this.slotLabels[key]) {
            this.slotLabels[key] = toUpperSafe(label);
          }
          const normalizedLevel = Number.isFinite(levelHint)
            ? levelHint
            : opts.manual
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY;
          const existing = firstSeen.get(key);
          if (!existing) {
            firstSeen.set(key, { level: normalizedLevel, index: serial++ });
          } else if (normalizedLevel < existing.level) {
            existing.level = normalizedLevel;
          }
        };

        manualOrder.forEach((slot) => {
          recordSlot(slot, this.slotLabels[String(slot)] || null, Number.NEGATIVE_INFINITY, { manual: true });
        });

        for (const [slot, data] of Object.entries(this.baseline || {})) {
          if (data == null) continue;
          const unlockLevel =
            data && typeof data === 'object' && Number.isFinite(data.unlockLevel) ? data.unlockLevel : this.minLevel;
          recordSlot(slot, this.resolveSlotType(data), unlockLevel);
        }

        const sortedLevels = Object.keys(this.changes || {})
          .map((value) => Number(value))
          .filter((value) => Number.isFinite(value))
          .sort((a, b) => a - b);

        for (const level of sortedLevels) {
          const changeSet = this.changes[level];
          if (!changeSet || typeof changeSet !== 'object') continue;
          for (const [slot, payload] of Object.entries(changeSet)) {
            if (payload === undefined || payload === null) {
              recordSlot(slot, null, level);
              continue;
            }
            const unlockLevel =
              payload && typeof payload === 'object' && Number.isFinite(payload.unlockLevel) ? payload.unlockLevel : level;
            recordSlot(slot, this.resolveSlotType(payload), unlockLevel);
          }
        }

        const entries = Array.from(firstSeen.entries());
        const big = Number.POSITIVE_INFINITY;
        entries.sort((a, b) => {
          const aKey = a[0];
          const bKey = b[0];
          const aManual = manualIndex.has(aKey);
          const bManual = manualIndex.has(bKey);
          if (aManual && bManual) {
            return manualIndex.get(aKey) - manualIndex.get(bKey);
          }
          if (aManual) return -1;
          if (bManual) return 1;
          const aLevel = Number.isFinite(a[1].level) ? a[1].level : big;
          const bLevel = Number.isFinite(b[1].level) ? b[1].level : big;
          if (aLevel !== bLevel) return aLevel - bLevel;
          return a[1].index - b[1].index;
        });

        return entries.map(([key]) => key);
      }

      getSlotLabel(slotKey) {
        const label = this.slotLabels[String(slotKey)];
        if (typeof label === 'string') return label;
        const snapshot = this.baseline[slotKey];
        if (snapshot) {
          if (snapshot.type) return toUpperSafe(snapshot.type);
          if (typeof snapshot === 'string') {
            const lookup = resolveAttachmentFromDb(this.dbname, snapshot);
            if (lookup && lookup.type) return toUpperSafe(lookup.type);
          } else if (snapshot.name) {
            const lookup = resolveAttachmentFromDb(this.dbname, snapshot.name);
            if (lookup && lookup.type) return toUpperSafe(lookup.type);
          }
        }
        return `SLOT ${slotKey}`;
      }

      clampLevel(level) {
        const value = Math.round(level);
        return Math.max(this.minLevel, Math.min(this.maxLevel, value));
      }

  mount(template) {
    const fragment = template.content.cloneNode(true);
    this.cardEl = fragment.querySelector('.weapon-card');
    this.cardEl.dataset.weaponId = this.id;

        this.headerEl = this.cardEl.querySelector('.weapon-header');
        this.headerTextEl = this.cardEl.querySelector('.weapon-header-text');
        this.chevronBtn = this.cardEl.querySelector('.chevron-toggle');
        this.headerLevelEl = this.cardEl.querySelector('.header-level');
        this.dragHandleBtn = this.cardEl.querySelector('.drag-handle');
        this.favoriteBtn = this.cardEl.querySelector('.favorite-toggle');
        this.collapseBoxBtn = this.cardEl.querySelector('.collapse-box');
        this.favoriteIcon = this.favoriteBtn ? this.favoriteBtn.querySelector('span[aria-hidden="true"]') : null;
        this.favoriteText = this.favoriteBtn ? this.favoriteBtn.querySelector('.favorite-text') : null;
        this.collapseBtn = this.cardEl.querySelector('.collapse-toggle');
        this.weaponNameEl = this.cardEl.querySelector('.weapon-name');
        this.weaponTypeEl = this.cardEl.querySelector('.weapon-subtitle');
        this.typeChipEl = this.cardEl.querySelector('.type-chip');
        this.rankChipEl = this.cardEl.querySelector('.rank-chip');
        this.rangeChipEl = this.cardEl.querySelector('.range-chip');
        this.weaponImageWrapEl = this.cardEl.querySelector('.weapon-image-wrap');
        this.weaponImageEl = this.cardEl.querySelector('.weapon-image');
        this.weaponImagePhEl = this.cardEl.querySelector('.weapon-image-ph');
        this.levelPillEl = this.cardEl.querySelector('.level-pill');
        this.levelDisplayEl = this.cardEl.querySelector('.level-display');
        this.progressBarEl = this.cardEl.querySelector('.level-slider');
        this.levelDownBtn = this.cardEl.querySelector('.level-down');
        this.levelUpBtn = this.cardEl.querySelector('.level-up');
        this.apMeterEl = this.cardEl.querySelector('.ap-meter');
        this.apValueEl = this.cardEl.querySelector('.ap-value');
        this.apMaxEl = this.cardEl.querySelector('.ap-max');
        this.slotsEl = this.cardEl.querySelector('.slots');
        this.changesPanelEl = this.cardEl.querySelector('.changes-panel');
        this.recommendedPanelEl = this.cardEl.querySelector('.recommended-panel');
        this.recommendedListEl = this.cardEl.querySelector('.recommended-list');
        // Mini AP meter inside Recommended panel
        this.recommendedApMeterEl = this.recommendedPanelEl ? this.recommendedPanelEl.querySelector('.ap-meter') : null;
        this.recommendedApValueEl = this.recommendedPanelEl ? this.recommendedPanelEl.querySelector('.ap-value') : null;
        this.recommendedApMaxEl = this.recommendedPanelEl ? this.recommendedPanelEl.querySelector('.ap-max') : null;
        this.buildTabsEl = this.cardEl.querySelector('.build-tabs');
        this.buildTabListEl = this.cardEl.querySelector('.build-tablist');
        this.buildTabButtons = [];
        this.setupBuildTabs();

        if (this.weaponNameEl) this.weaponNameEl.textContent = toUpperSafe(this.displayName || this.id);
        if (this.weaponTypeEl) this.weaponTypeEl.textContent = toUpperSafe(this.displayType || 'Mastery Loadout Progression');
        if (this.typeChipEl) {
          const typeLabel = toUpperSafe(this.displayType || 'Type Not Found');
          this.typeChipEl.textContent = typeLabel;
        }
        if (this.rankChipEl) {
          const r = (this.config.rank || '').toString().trim().toLowerCase();
          const map = { m: 'META', a: 'A TIER', b: 'B TIER', c: 'C TIER', d: 'D TIER' };
          const label = map[r] || 'UNRANKED';
          this.rankChipEl.textContent = label;
          this.rankChipEl.classList.remove('rank-m','rank-a','rank-b','rank-c','rank-d','rank-unranked');
          this.rankChipEl.classList.add(r && map[r] ? ('rank-' + r) : 'rank-unranked');
        }
        if (this.rangeChipEl) {
          const code = (this.config.tr || '').toString().trim().toUpperCase();
          const num = parseInt(code, 10);
          const typeLabel = toUpperSafe(this.displayType || 'TYPE');
          if (Number.isFinite(num) && num >= 1 && typeLabel) {
            const cssIndex = Math.min(4, num);
            this.rangeChipEl.textContent = '#' + num + ' ' + typeLabel;
            this.rangeChipEl.classList.remove('range-1','range-2','range-3','range-4','range-unranked');
            this.rangeChipEl.classList.add('range-' + cssIndex);
          } else {
            this.rangeChipEl.textContent = 'UNRANKED';
            this.rangeChipEl.classList.remove('range-1','range-2','range-3','range-4');
            this.rangeChipEl.classList.add('range-unranked');
          }
          if (!this.rangeChipEl.textContent || !this.rangeChipEl.textContent.trim()) {
            this.rangeChipEl.textContent = 'UNRANKED';
            this.rangeChipEl.classList.add('range-unranked');
          }
        }
        if (this.weaponImageWrapEl && this.weaponImageEl) {
          const imgName = this.displayImage;
          if (imgName) {
            const nameOrId = toUpperSafe(this.displayName || this.id);
            const hasPath = /[\\/]/.test(imgName) || /^(https?:)?\/\//i.test(imgName);
            const primary = hasPath ? imgName : `images/${imgName}`;
            const alternate = hasPath ? imgName : `Images/${imgName}`;
            let triedAlt = false;

            this.weaponImageWrapEl.classList.remove('placeholder');
            this.weaponImageEl.alt = nameOrId;
            const onError = () => {
              if (!triedAlt && alternate !== primary) {
                triedAlt = true;
                this.weaponImageEl.src = alternate;
              } else {
                this.weaponImageEl.removeEventListener('error', onError);
                this.weaponImageEl.removeAttribute('src');
                this.weaponImageWrapEl.classList.add('placeholder');
                this.weaponImageEl.alt = '';
              }
            };
            this.weaponImageEl.addEventListener('error', onError);
            this.weaponImageEl.addEventListener('load', () => {
              // On success, ensure placeholder is hidden and stop error fallback
              this.weaponImageWrapEl.classList.remove('placeholder');
              this.weaponImageEl.removeEventListener('error', onError);
            }, { once: true });
            this.weaponImageEl.src = primary;
          } else {
            this.weaponImageWrapEl.classList.add('placeholder');
            this.weaponImageEl.removeAttribute('src');
            this.weaponImageEl.alt = '';
          }
        }
        if (this.apMaxEl) this.apMaxEl.textContent = `/${this.apMax}`;

        if (this.progressBarEl) {
          this.progressBarEl.setAttribute('min', String(this.minLevel));
          this.progressBarEl.setAttribute('max', String(this.maxLevel));
          this.progressBarEl.setAttribute('step', '1');
          this.progressBarEl.setAttribute('aria-valuemin', String(this.minLevel));
          this.progressBarEl.setAttribute('aria-valuemax', String(this.maxLevel));
          this.progressBarEl.setAttribute('draggable', 'false');
        }

        if (this.levelDownBtn) this.levelDownBtn.addEventListener('click', () => this.setLevel(this.state.level - 1));
        if (this.levelUpBtn) this.levelUpBtn.addEventListener('click', () => this.setLevel(this.state.level + 1));
        if (this.progressBarEl) {
          const stopPropagation = (event) => {
            event.stopPropagation();
          };
          const disableHeaderDrag = () => {
            if (this.headerEl) this.headerEl.setAttribute('draggable', 'false');
          };
          const enableHeaderDrag = () => {
            if (this.headerEl) this.headerEl.setAttribute('draggable', 'true');
          };
          const pointerDownHandler = (event) => {
            stopPropagation(event);
            disableHeaderDrag();
          };
          this.progressBarEl.addEventListener('pointerdown', pointerDownHandler);
          this.progressBarEl.addEventListener('mousedown', pointerDownHandler);
          this.progressBarEl.addEventListener('touchstart', pointerDownHandler, { passive: true });
          ['pointerup', 'pointerleave', 'pointercancel', 'touchend', 'touchcancel', 'keyup', 'blur'].forEach((type) => {
            this.progressBarEl.addEventListener(type, enableHeaderDrag);
          });
          this.progressBarEl.addEventListener('dragstart', (event) => event.preventDefault());
          this.progressBarEl.addEventListener('input', (event) => {
            const target = event.currentTarget;
            if (!(target instanceof HTMLInputElement)) return;
            const raw = Number(target.value);
            if (!Number.isFinite(raw)) return;
            this.setLevel(raw);
          });
        }
        if (this.weaponImageWrapEl) {
          // Prevent drag-to-reorder from the image area
          this.weaponImageWrapEl.setAttribute('draggable', 'false');
          this.weaponImageWrapEl.addEventListener('dragstart', (e) => { e.preventDefault(); });
          this.weaponImageWrapEl.addEventListener('pointerdown', (e) => { e.stopPropagation(); });
        }
        const controlStack = this.cardEl.querySelector('.control-stack');
        if (controlStack) {
          controlStack.setAttribute('draggable', 'false');
          controlStack.addEventListener('dragstart', (e) => { e.preventDefault(); });
          controlStack.addEventListener('pointerdown', (e) => { e.stopPropagation(); });
        }
        if (this.favoriteBtn) this.favoriteBtn.addEventListener('click', () => this.toggleFavorite());
        if (this.collapseBtn) this.collapseBtn.addEventListener('click', () => this.toggleCollapse());
        if (this.collapseBoxBtn) this.collapseBoxBtn.addEventListener('click', () => this.toggleCollapse());

        // Title block and chevron toggle collapse
        if (this.headerTextEl) {
          this.headerTextEl.addEventListener('click', (event) => {
            const target = event.target;
            if (target && target.closest && target.closest('.header-controls')) return;
            this.toggleCollapse();
          });
          this.headerTextEl.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              this.toggleCollapse();
            }
          });
        }
        if (this.chevronBtn) {
          this.chevronBtn.addEventListener('click', () => this.toggleCollapse());
        }

        if (this.dragHandleBtn) {
          this.dragHandleBtn.addEventListener('dragstart', (event) => this.handleDragStart(event));
          this.dragHandleBtn.addEventListener('dragend', () => this.handleDragEnd());
          // Remove legacy drag handle from DOM to slim header
          if (this.dragHandleBtn.parentElement) {
            this.dragHandleBtn.parentElement.removeChild(this.dragHandleBtn);
          }
        }
        if (this.headerEl) {
          this.headerEl.setAttribute('draggable', 'true');
          this.headerEl.addEventListener('dragstart', (event) => this.handleDragStart(event));
          this.headerEl.addEventListener('dragend', () => this.handleDragEnd());
        }

        this.cardEl.addEventListener('keydown', (event) => {
          const step = event.shiftKey ? 5 : 1;
          if (event.key === 'ArrowLeft') {
            event.preventDefault();
            this.setLevel(this.state.level - step);
          } else if (event.key === 'ArrowRight') {
            event.preventDefault();
            this.setLevel(this.state.level + step);
          } else if (event.key === 'Home') {
            event.preventDefault();
            this.setLevel(this.minLevel);
          } else if (event.key === 'End') {
            event.preventDefault();
            this.setLevel(this.maxLevel);
          }
        });

        this.applyFavoriteUI();
        this.applyCollapseState();
        if (this.progressBarEl) this.updateProgressUI(this.state.level);
        // Ensure recommended panel starts hidden unless data populates it.
        if (this.recommendedPanelEl) this.recommendedPanelEl.hidden = true;
        this.render();

        this.cardEl.remove();
      }
      attach(container) {
        if (!this.cardEl) return;
        container.appendChild(this.cardEl);
      }

      isFavorite() {
        return Boolean(this.state.favorite);
      }

      handleDragStart(event) {
        // Do not start reordering when dragging from interactive header controls or image
        if (event && event.target && event.target.closest && (event.target.closest('.header-controls') || event.target.closest('.weapon-image') || event.target.closest('.weapon-image-wrap') || event.target.closest('.control-stack') || event.target.closest('.collapse-box') || event.target.closest('.favorite-toggle'))) {
          event.preventDefault();
          return;
        }
        if (currentDraggedId && currentDraggedId !== this.id) {
          event.preventDefault();
          return;
        }
        currentDraggedId = this.id;
        setDragActiveState(true);
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', this.id);
        this.cardEl.classList.add('dragging');
      }

      handleDragEnd() {
        this.cardEl.classList.remove('dragging');
        clearCardDropPlaceholder();
        clearNavDropPlaceholder();
        currentDraggedId = null;
        setDragActiveState(false);
      }

      toggleFavorite() {
        this.state.favorite = !this.state.favorite;
        storage.updateWeaponState(this.id, { favorite: this.state.favorite });
        this.applyFavoriteUI();
        renderWeaponList();
      }

                  applyFavoriteUI() {
        if (this.cardEl) this.cardEl.classList.toggle('favorite', this.state.favorite);
        if (this.favoriteBtn) this.favoriteBtn.setAttribute('aria-pressed', this.state.favorite ? 'true' : 'false');
        if (this.favoriteIcon) {
          this.favoriteIcon.textContent = this.state.favorite ? '\u2605' : '\u2606';
        }
        if (this.favoriteText) {
          this.favoriteText.textContent = this.state.favorite ? 'Favorited' : 'Favorite';
        }
        if (this.favoriteBtn) {
          this.favoriteBtn.title = this.state.favorite ? 'Unfavorite' : 'Favorite';
        }
      }

      toggleCollapse() {
        this.state.collapsed = !this.state.collapsed;
        storage.updateWeaponState(this.id, { collapsed: this.state.collapsed });
        this.applyCollapseState();
        if (!this.state.collapsed) {
          this.render();
        }
      }

      applyCollapseState() {
        if (this.cardEl) this.cardEl.classList.toggle('collapsed', this.state.collapsed);
        if (this.collapseBtn) {
          this.collapseBtn.setAttribute('aria-expanded', this.state.collapsed ? 'false' : 'true');
          this.collapseBtn.textContent = this.state.collapsed ? 'Show' : 'Hide';
        }
        if (this.chevronBtn) this.chevronBtn.setAttribute('aria-expanded', this.state.collapsed ? 'false' : 'true');
        if (this.collapseBoxBtn) {
          this.collapseBoxBtn.textContent = this.state.collapsed ? '\u25B8' : '\u25BE';
          this.collapseBoxBtn.setAttribute('aria-expanded', this.state.collapsed ? 'false' : 'true');
        }
        if (this.headerTextEl) this.headerTextEl.setAttribute('aria-expanded', this.state.collapsed ? 'false' : 'true');
      }

      setLevel(level) {
        const next = this.clampLevel(level);
        if (next === this.state.level) return;
        this.state.level = next;
        storage.updateWeaponState(this.id, { level: next });
        this.render();
      }

      updateProgressUI(level) {
        if (!this.progressBarEl) return;
        this.progressBarEl.value = String(level);
        this.progressBarEl.setAttribute('aria-valuenow', String(level));
        const denominator = Math.max(1, this.maxLevel - this.minLevel);
        const percent = denominator === 0 ? 0 : ((level - this.minLevel) / denominator) * 100;
        this.progressBarEl.style.setProperty('--level-slider-fill', `${percent}%`);
      }
      ensureApMeterCells() {
        if (!this.apMeterEl || this.apMeterEl.children.length) return;
        const cellCount = Math.max(1, Math.round(this.apMax / 10));
        const frag = document.createDocumentFragment();
        for (let i = 0; i < cellCount; i++) {
          const cell = document.createElement('span');
          cell.className = 'ap-cell';
          const iconWrapper = document.createElement('span');
          iconWrapper.className = 'ap-icon';

          const icon = document.createElement('img');
          icon.src = AP_ICON;
          icon.alt = 'Attachment Points';
          iconWrapper.appendChild(icon);

          const firstFill = document.createElement('span');
          firstFill.className = 'ap-fill first';
          iconWrapper.appendChild(firstFill);

          const secondFill = document.createElement('span');
          secondFill.className = 'ap-fill second';
          iconWrapper.appendChild(secondFill);

          cell.appendChild(iconWrapper);
          frag.appendChild(cell);
        }
        this.apMeterEl.appendChild(frag);
      }

      updateApMeter(total, overcap = false) {
        this.ensureApMeterCells();
        if (this.apMeterEl) {
          this.apMeterEl.classList.toggle('ap-overcap', overcap);
        }
        if (!this.apMeterEl) return;
        const cells = Array.from(this.apMeterEl.children);
        if (!cells.length) return;
        if (this.apMax <= 0) {
          cells.forEach((cell) => cell.classList.remove('half', 'full'));
          return;
        }
        const cappedTotal = Math.max(0, Math.min(total, this.apMax));
        const perCell = this.apMax / cells.length;
        cells.forEach((cell, index) => {
          const cellMin = perCell * index;
          const cellMax = cellMin + perCell;
          const amountInCell = Math.max(0, Math.min(cappedTotal, cellMax) - cellMin);
          const halfThreshold = perCell / 2;
          const isFull = amountInCell >= perCell - 0.01;
          const isHalf = !isFull && amountInCell >= halfThreshold - 0.01;
          cell.classList.remove('half', 'full');
          if (isFull) {
            cell.classList.add('full');
          } else if (isHalf) {
            cell.classList.add('half');
          }
        });
      }

      // Helpers to drive an AP meter for a specific element (used by Recommended panel)
      ensureApMeterCellsFor(meterEl) {
        if (!meterEl || meterEl.children.length) return;
        const cellCount = Math.max(1, Math.round(this.apMax / 10));
        const frag = document.createDocumentFragment();
        for (let i = 0; i < cellCount; i++) {
          const cell = document.createElement('span');
          cell.className = 'ap-cell';
          const iconWrapper = document.createElement('span');
          iconWrapper.className = 'ap-icon';
          const icon = document.createElement('img');
          icon.src = AP_ICON;
          icon.alt = 'Attachment Points';
          iconWrapper.appendChild(icon);
          const firstFill = document.createElement('span');
          firstFill.className = 'ap-fill first';
          iconWrapper.appendChild(firstFill);
          const secondFill = document.createElement('span');
          secondFill.className = 'ap-fill second';
          iconWrapper.appendChild(secondFill);
          cell.appendChild(iconWrapper);
          frag.appendChild(cell);
        }
        meterEl.appendChild(frag);
      }

      updateApMeterFor(meterEl, total, overcap = false) {
        if (!meterEl) return;
        this.ensureApMeterCellsFor(meterEl);
        meterEl.classList.toggle('ap-overcap', overcap);
        const cells = Array.from(meterEl.children);
        if (!cells.length) return;
        const max = this.apMax;
        if (max <= 0) {
          cells.forEach((cell) => cell.classList.remove('half', 'full'));
          return;
        }
        const cappedTotal = Math.max(0, Math.min(total, max));
        const perCell = max / cells.length;
        cells.forEach((cell, index) => {
          const cellMin = perCell * index;
          const cellMax = cellMin + perCell;
          const amountInCell = Math.max(0, Math.min(cappedTotal, cellMax) - cellMin);
          const halfThreshold = perCell / 2;
          const isFull = amountInCell >= perCell - 0.01;
          const isHalf = !isFull && amountInCell >= halfThreshold - 0.01;
          cell.classList.remove('half', 'full');
          if (isFull) cell.classList.add('full');
          else if (isHalf) cell.classList.add('half');
        });
      }

      createApDisplay(value) {
        if (!Number.isFinite(value)) return null;
        const wrapper = document.createElement('span');
        wrapper.className = 'ap-inline';
        const icon = document.createElement('img');
        icon.src = AP_ICON;
        icon.alt = 'Attachment Points';
        wrapper.appendChild(icon);
        const text = document.createElement('span');
        text.textContent = `${value}`;
        wrapper.appendChild(text);
        return wrapper;
      }

      createCard(data, options = {}) {
        if (!data) return null;
        const card = document.createElement('div');
        card.className = 'slot-card';
        if (options.old) card.classList.add('old');
        if (options.changed) card.classList.add('changed');
        if (options.indented) card.classList.add('indented');
        if (options.removed) card.classList.add('removed');

        const top = document.createElement('div');
        top.className = 'card-top';

        const info = document.createElement('div');
        info.className = 'card-info';

        const title = document.createElement('div');
        title.className = 'card-title';
        title.textContent = toUpperSafe(data.name);
        info.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'card-meta';
        const type = document.createElement('span');
        type.className = 'meta-type';
        type.textContent = toUpperSafe(data.type || 'ATTACHMENT');
        meta.appendChild(type);

        if (typeof data.pts === 'number') {
          const separator = document.createElement('span');
          separator.className = 'meta-separator';
          separator.textContent = '\u2022';
          meta.appendChild(separator);

          const pts = this.createApDisplay(data.pts);
          if (pts) {
            pts.classList.add('meta-pts');
            meta.appendChild(pts);
          }
        }

        info.appendChild(meta);
        top.appendChild(info);

        const levelBadge = document.createElement('div');
        levelBadge.className = 'card-level';
        const displayLevelRaw = options.level ?? data.unlockLevel;
        const displayLevel =
          typeof displayLevelRaw === 'string' ? displayLevelRaw.trim() : displayLevelRaw;
        const isDefaultLevel =
          displayLevel === 0 ||
          displayLevel === '0' ||
          (typeof displayLevel === 'number' && Number.isFinite(displayLevel) && displayLevel === 0);
        if (options.hideLevel) {
          levelBadge.textContent = 'Unlocked';
        } else if (isDefaultLevel) {
          levelBadge.textContent = 'Default';
        } else if (displayLevel !== undefined && displayLevel !== null && displayLevel !== '') {
          levelBadge.textContent = `Level ${displayLevel}`;
        } else {
          levelBadge.textContent = 'Unlocked';
        }
        top.appendChild(levelBadge);

        card.appendChild(top);

        if (typeof data.description === 'string' && data.description.trim()) {
          const description = document.createElement('div');
          description.className = 'card-description';
          description.textContent = data.description.trim();
          card.appendChild(description);
        }

        return card;
      }

      createPlaceholderCard() {
        // Placeholder no longer renders a visible box; return an empty fragment
        const frag = document.createDocumentFragment();
        return frag;
      }
      computeState(level) {
        const snapshot = {};
        for (const slot of this.slotKeys) {
          snapshot[slot] = null;
        }

        for (const [slot, data] of Object.entries(this.baseline || {})) {
          if (data == null) continue;
          const slotKey = String(slot);
          const hasExplicitLevel = data && typeof data === 'object' && Number.isFinite(data.unlockLevel);
          const unlockLevel = hasExplicitLevel ? data.unlockLevel : undefined;
          const entry = normalizeEntry(data, hasExplicitLevel ? unlockLevel : undefined, this.dbname);
          if (entry) {
            if (!Number.isFinite(entry.unlockLevel)) {
              entry.unlockLevel = hasExplicitLevel ? unlockLevel : this.minLevel;
            }
            snapshot[slotKey] = entry;
          }
        }

        const sortedLevels = Object.keys(this.changes || {})
          .map((value) => Number(value))
          .filter((value) => !Number.isNaN(value))
          .sort((a, b) => a - b);

        for (const changeLevel of sortedLevels) {
          if (changeLevel > level) break;
          const changeSet = this.changes[changeLevel];
          if (!changeSet || typeof changeSet !== 'object') continue;
          for (const [slot, payload] of Object.entries(changeSet)) {
            const slotKey = String(slot);
            if (payload === null) {
              snapshot[slotKey] = null;
            } else {
              const hasExplicitLevel =
                payload && typeof payload === 'object' && Number.isFinite(payload.unlockLevel);
              const unlockLevel = hasExplicitLevel ? payload.unlockLevel : changeLevel;
              const entry = normalizeEntry(payload, unlockLevel, this.dbname);
              if (entry) {
                snapshot[slotKey] = entry;
              }
            }
          }
        }

        return snapshot;
      }

      diffAtLevel(level) {
        const changeSet = this.changes[level];
        if (!changeSet || typeof changeSet !== 'object') return {};
        const diff = {};
        for (const [slot, payload] of Object.entries(changeSet)) {
          const slotKey = String(slot);
          if (payload === null) {
            diff[slotKey] = null;
          } else {
            const hasExplicitLevel =
              payload && typeof payload === 'object' && Number.isFinite(payload.unlockLevel);
            const unlockLevel = hasExplicitLevel ? payload.unlockLevel : level;
            const entry = normalizeEntry(payload, unlockLevel, this.dbname);
            if (entry) {
              diff[slotKey] = entry;
            }
          }
        }
        return diff;
      }

      renderSlots(level) {
        this.slotsEl.innerHTML = '';
        const current = this.computeState(level);
        const previous = this.computeState(Math.max(this.minLevel - 1, level - 1));
        const diff = this.diffAtLevel(level);
        const arrowPairs = [];

        for (const slot of this.slotKeys) {
          const wrapper = document.createElement('div');
          wrapper.className = 'slot-wrapper';
          const label = document.createElement('div');
          label.className = 'slot-label';
          label.textContent = this.getSlotLabel(slot);
          wrapper.appendChild(label);
          let hasCard = false;

          const change = diff.hasOwnProperty(slot) ? diff[slot] : undefined;

          if (change !== undefined) {
            const previousData = previous[slot];
            if (change === null) {
              if (previousData) {
                const oldLevel = Number.isFinite(previousData.unlockLevel)
                  ? previousData.unlockLevel
                  : level;
                const oldCard = this.createCard(previousData, {
                  old: true,
                  removed: true,
                  level: oldLevel
                });
                if (oldCard) {
                  wrapper.appendChild(oldCard);
                  hasCard = true;
                }
              } else {
                // No previous attachment; do not render a placeholder box
              }
            } else {
              const replacedMeta = Array.isArray(change.replaced) ? change.replaced : [];
              let oldCardData = previousData ? { ...previousData } : null;
              let oldLevel = oldCardData && Number.isFinite(oldCardData.unlockLevel)
                ? oldCardData.unlockLevel
                : level;

              if (replacedMeta.length) {
                const match = oldCardData
                  ? replacedMeta.find((entry) => entry.name === oldCardData.name)
                  : replacedMeta[0];
                if (match) {
                  if (oldCardData) {
                    oldCardData = { ...oldCardData, ...match };
                  } else {
                    oldCardData = {
                      name: match.name || 'Previous attachment',
                      pts: match.pts ?? 0,
                      type: match.type || this.getSlotLabel(slot),
                      unlockLevel: Number.isFinite(match.unlockLevel) ? match.unlockLevel : level
                    };
                  }
                  oldLevel = Number.isFinite(match.unlockLevel)
                    ? match.unlockLevel
                    : oldCardData.unlockLevel ?? level;
                  const normalized = normalizeEntry(
                    oldCardData,
                    Number.isFinite(oldCardData.unlockLevel) ? oldCardData.unlockLevel : oldLevel,
                    this.dbname
                  );
                  if (normalized) {
                    oldCardData = normalized;
                  }
                }
              }

              let oldCard = null;
              if (oldCardData) {
                oldCard = this.createCard(oldCardData, { old: true, level: oldLevel });
                if (oldCard) {
                  wrapper.appendChild(oldCard);
                  hasCard = true;
                }
              }

              const newCard = this.createCard(change, {
                changed: true,
                indented: Boolean(oldCard),
                level: Number.isFinite(change.unlockLevel) ? change.unlockLevel : level
              });
              if (newCard) {
                wrapper.appendChild(newCard);
                hasCard = true;
              }
              if (oldCard && newCard) {
                arrowPairs.push({ oldEl: oldCard, newEl: newCard });
              }
            }
          } else {
            const currentData = current[slot];
            if (currentData) {
              const prevData = previous[slot];
              const changed = prevData ? prevData.name !== currentData.name : level > this.minLevel;
              const card = this.createCard(currentData, {
                changed,
                level: currentData.unlockLevel,
                hideLevel: currentData.unlockLevel ? currentData.unlockLevel > level : false
              });
              if (card) {
                wrapper.appendChild(card);
                hasCard = true;
              }
            } else {
              // No current attachment; do not render a placeholder box
            }
          }

          if (hasCard) {
            this.slotsEl.appendChild(wrapper);
          }
        }

        this.arrowLayerEl.innerHTML = '';
        this.slotsEl.appendChild(this.arrowLayerEl);
        requestAnimationFrame(() => this.drawArrows(arrowPairs));
      }

      renderChanges(level) {
        if (!this.changesPanelEl) return;
        const container = this.changesPanelEl;
        container.innerHTML = '';

        const activeBuild = this.buildById ? this.buildById[this.activeBuildId] : null;
        const viewingBuild = activeBuild && activeBuild.type !== 'mastery';
        if (viewingBuild) {
          const title = document.createElement('h3');
          title.textContent = this.activeBuildNote ? `${activeBuild.label} Notes` : `${activeBuild.label}`;
          container.appendChild(title);
          const body = document.createElement('div');
          body.className = 'changes-empty';
          if (this.activeBuildNote) {
            body.innerHTML = this.formatNotesText(this.activeBuildNote);
          } else {
            body.textContent = 'No notes available for this build.';
          }
          container.appendChild(body);
          return;
        }

        const diff = this.diffAtLevel(level);
        const previous = this.computeState(Math.max(this.minLevel - 1, level - 1));
        const entries = Object.entries(diff);
        const title = document.createElement('h3');
        title.textContent = 'Changes at this Level';
        container.appendChild(title);

        if (!entries.length) {
          const empty = document.createElement('div');
          empty.className = 'changes-empty';
          empty.textContent = 'No changes unlocked at this level.';
          container.appendChild(empty);
          return;
        }

        for (const [slot, change] of entries) {
          const row = document.createElement('div');
          row.className = 'change-row';
          const slotName = this.getSlotLabel(slot) || `SLOT ${slot}`;
          const heading = document.createElement('div');
          heading.className = 'change-heading';

          if (change === null) {
            const prev = previous[slot];
            const prevName = prev ? prev.name : 'Previous attachment';
            const prevNameDisplay = toUpperSafe(prevName);
            // Normalize corrupted separators in some encodings
            heading.textContent = `${slotName} \u2014 Removed`;
            const detail = document.createElement('div');
            detail.className = 'change-detail';
            detail.textContent = `${prevNameDisplay} removed at Level ${level}.`;
            row.appendChild(heading);
            row.appendChild(detail);
          } else {
            const prev = previous[slot];
            const replacedMeta = Array.isArray(change.replaced) ? change.replaced : [];
            const fallbackPrev = prev
              ? null
              : replacedMeta.find((entry) => entry && entry.name) || replacedMeta[0] || null;
            const prevName = prev
              ? prev.name
              : fallbackPrev && fallbackPrev.name
              ? fallbackPrev.name
              : 'Baseline';
            const changeLevel = Number.isFinite(change.unlockLevel) ? change.unlockLevel : level;
            // Normalize corrupted separators in some encodings
            heading.textContent = `${slotName} \u2014 Level ${changeLevel}`;
            const detail = document.createElement('div');
            detail.className = 'change-detail';

            const prevSpan = document.createElement('span');
            prevSpan.className = 'change-prev';
            prevSpan.textContent = toUpperSafe(prevName);

            const arrow = document.createElement('span');
            arrow.className = 'change-arrow';
            arrow.textContent = '\u2192';

            const nextSpan = document.createElement('span');
            nextSpan.className = 'change-next';
            nextSpan.textContent = toUpperSafe(change.name);

            detail.appendChild(prevSpan);
            detail.appendChild(arrow);
            detail.appendChild(nextSpan);

            row.appendChild(heading);
            row.appendChild(detail);
          }

        container.appendChild(row);
      }
    }

      formatNotesText(note) {
        if (!note || typeof note !== 'string') return '';
        let text = note.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const mapping = [
          { tag: 'b', open: '<b>', close: '</b>' },
          { tag: 'i', open: '<i>', close: '</i>' },
          { tag: 'hl', open: '<span class="notes-highlight">', close: '</span>' },
          { tag: 'c', open: '<span class="notes-color">', close: '</span>' }
        ];
        for (const item of mapping) {
          const openPattern = new RegExp(`&lt;${item.tag}&gt;`, 'gi');
          const closePattern = new RegExp(`&lt;/${item.tag}&gt;`, 'gi');
          text = text.replace(openPattern, item.open);
          text = text.replace(closePattern, item.close);
        }
        return text;
      }

      hasMasteryData() {
        const baselineKeys = this.baseline ? Object.keys(this.baseline) : [];
        const changeKeys = this.changes ? Object.keys(this.changes) : [];
        return baselineKeys.length > 0 || changeKeys.length > 0;
      }

      resolveBuildDefinitions() {
      const recognized = [
        { id: 'recommended', label: 'Recommended', keys: ['recommended', 'recommendedBuild', 'recommended_build'] },
        { id: 'versatile', label: 'Versatile', keys: ['versatile'] },
        { id: 'close', label: 'Close Range', keys: ['close'] },
        { id: 'long', label: 'Long Range', keys: ['long'] },
        { id: 'sniper', label: 'Sniper', keys: ['sniper'] },
        { id: 'ss', label: 'Sniper Support', keys: ['ss', 'snipersupport'] },
        { id: 'mid', label: 'Medium Range', keys: ['mid', 'mediumrange'] },
        { id: 'custom', label: 'Custom', keys: ['custom'] }
      ];
        const lookup = {};
        for (const info of recognized) {
          for (const key of info.keys) {
            lookup[key.toLowerCase()] = info.id;
          }
        }
        const builds = [];
        if (this.hasMasteryData()) {
          builds.push({ id: 'mastery', label: 'Mastery', type: 'mastery' });
        }
        const seen = new Set(builds.map((build) => build.id));
        for (const key of Object.keys(this.config)) {
          const normalized = key.toString().trim().toLowerCase();
          const buildId = lookup[normalized];
        if (!buildId || seen.has(buildId)) continue;
        const info = recognized.find((entry) => entry.id === buildId);
        let payload = this.config[key];
        let label = info ? info.label : buildId;
        if (buildId === 'custom' && Array.isArray(payload)) {
          const first = payload[0];
          if (first && typeof first === 'object' && typeof first.custom === 'string') {
            label = first.custom;
            payload = payload.slice(1);
          }
        }
        if (payload == null) continue;
        seen.add(buildId);
        builds.push({
          id: buildId,
          label,
          type: 'list',
          payload,
          sourceKey: key
          });
        }
        return builds;
      }

      getBuildPayloadEntries(build) {
        if (!build || build.type !== 'list') return { entries: [], note: null };
        const payload = build.payload;
        let items = [];
        if (Array.isArray(payload)) {
          items = payload.slice();
        } else if (payload && typeof payload === 'object') {
          try {
            items = Object.values(payload);
          } catch (_) {
            items = [];
          }
        }
        let note = null;
        const filtered = [];
        for (const item of items) {
          if (item && typeof item === 'object') {
            const noteValue = item.Notes || item.notes;
            if (typeof noteValue === 'string' && noteValue.trim()) {
              note = noteValue.trim();
              continue;
            }
          }
          filtered.push(item);
        }
        return { entries: filtered, note };
      }

      renderBuildAttachments(build) {
        if (!this.slotsEl) return null;
        const { entries, note } = this.getBuildPayloadEntries(build);
        this.activeBuildNote = note;
        this.slotsEl.innerHTML = '';
        this.arrowLayerEl.innerHTML = '';
        if (!entries.length) {
          this.activeBuildApStats = null;
          return null;
        }
        const frag = document.createDocumentFragment();
        let totalAp = 0;
        let highestLevel = Number.NEGATIVE_INFINITY;
        for (const payload of entries) {
          if (!payload) continue;
          const unlock = Number.isFinite(payload.unlockLevel) ? payload.unlockLevel : undefined;
          const entry = normalizeEntry(payload, unlock, this.dbname);
          if (!entry) continue;
          const card = this.createCard(entry, { changed: true, hideLevel: false, level: entry.unlockLevel });
          if (card) frag.appendChild(card);
          if (typeof entry.pts === 'number') totalAp += entry.pts;
          if (Number.isFinite(entry.unlockLevel)) {
            highestLevel = Math.max(highestLevel, entry.unlockLevel);
          }
        }
        if (!frag.childElementCount) {
          this.activeBuildApStats = null;
          return null;
        }
        this.slotsEl.appendChild(frag);
        const stats = { totalAp, overcap: Number.isFinite(this.apMax) && totalAp > this.apMax };
        stats.requiredLevel = Number.isFinite(highestLevel) ? highestLevel : null;
        this.activeBuildApStats = stats;
        return stats;
      }

      setupBuildTabs() {
        if (!this.buildTabsEl || !this.buildTabListEl) return;
        this.buildTabListEl.innerHTML = '';
        this.buildTabButtons = [];
        if (!this.buildDefinitions.length) {
          this.buildTabsEl.hidden = true;
          return;
        }
        this.buildTabsEl.hidden = this.buildDefinitions.length === 0;
        for (const build of this.buildDefinitions) {
          const tab = document.createElement('button');
          tab.type = 'button';
          tab.className = 'build-tab';
          tab.dataset.build = build.id;
          tab.setAttribute('role', 'tab');
          tab.textContent = build.label;
          tab.addEventListener('click', () => this.setActiveBuild(build.id));
          this.buildTabListEl.appendChild(tab);
          this.buildTabButtons.push(tab);
        }
        this.updateBuildTabSelection();
        this.renderBuildView();
      }

      updateBuildTabSelection() {
        if (!this.buildTabButtons.length) return;
        for (const tab of this.buildTabButtons) {
          const isActive = tab.dataset.build === this.activeBuildId;
          tab.classList.toggle('active', isActive);
          tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
        }
      }

      setActiveBuild(buildId) {
        if (!buildId || buildId === this.activeBuildId) return;
        this.activeBuildId = buildId;
        this.updateBuildTabSelection();
        if (this.cardEl) {
          this.cardEl.dataset.activeBuild = buildId;
        }
        persistActiveTab(this.id, buildId);
        this.renderBuildView();
        this.render();
      }

      renderBuildView() {
        if (!this.cardEl) return;
        if (this.buildTabsEl) {
          this.buildTabsEl.hidden = this.buildDefinitions.length === 0;
        }
        if (this.activeBuildId) {
          this.cardEl.dataset.activeBuild = this.activeBuildId;
        } else {
          this.cardEl.removeAttribute('data-active-build');
        }
      }

      updateAp(level) {
        const snapshot = this.computeState(level);
        let total = 0;
        for (const value of Object.values(snapshot)) {
          if (value && typeof value.pts === 'number') {
            total += value.pts;
          }
        }
        const overcap = Number.isFinite(this.apMax) && total > this.apMax;
        if (this.apValueEl) {
          this.apValueEl.textContent = `${Math.round(total)}`;
        }
        if (this.apMaxEl) this.apMaxEl.textContent = `/${this.apMax}`;
        const readout = this.apValueEl ? this.apValueEl.closest('.ap-readout') : null;
        if (readout) readout.classList.toggle('ap-overcap', overcap);
        this.updateApMeter(total, overcap);
        return total;
      }

      applyBuildApStats(stats) {
        if (!stats || !this.apValueEl) return;
        const totalAp = Number.isFinite(stats.totalAp) ? stats.totalAp : 0;
        const overcap = Boolean(stats.overcap);
        if (this.apValueEl) {
          const displayValue = Number.isFinite(totalAp) && totalAp > 0 ? `${Math.round(totalAp)}` : '';
          this.apValueEl.textContent = displayValue;
        }
        if (this.apMaxEl) this.apMaxEl.textContent = `/${this.apMax}`;
        const readout = this.apValueEl ? this.apValueEl.closest('.ap-readout') : null;
        if (readout) readout.classList.toggle('ap-overcap', overcap);
        this.updateApMeter(totalAp, overcap);
      }

      updateLevelDisplayForBuild(stats) {
        if (!this.levelDisplayEl) return;
        if (stats && Number.isFinite(stats.requiredLevel)) {
          this.levelDisplayEl.textContent = `Full build requires Mastery ${Math.round(stats.requiredLevel)}.`;
        } else {
          this.levelDisplayEl.textContent = '';
        }
      }

      updateLevelDisplayDefault(level) {
        if (!this.levelDisplayEl) return;
        this.levelDisplayEl.textContent = `Viewing mastery unlocks at level ${level}.`;
      }

      drawArrows(pairs) {
        this.arrowLayerEl.innerHTML = '';
        if (!pairs.length) return;
        const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#00e5ff';

        for (const pair of pairs) {
          if (!pair.oldEl || !pair.newEl) continue;
          const startY = this.offsetWithinContainer(pair.oldEl) + pair.oldEl.offsetHeight;
          const endY = this.offsetWithinContainer(pair.newEl) + pair.newEl.offsetHeight / 2;
          const vertical = Math.max(0, endY - startY);
          const height = vertical + 16;
          const arrowSize = 6;
          const oldLeft = this.offsetLeftWithinContainer(pair.oldEl);
          const newLeft = this.offsetLeftWithinContainer(pair.newEl);
          const baseLeft = Math.min(oldLeft, newLeft);
          const startX = CARD_PAD + 1 + (oldLeft - baseLeft);
          const rawTargetX = newLeft - baseLeft;
          const targetX = Math.max(startX, rawTargetX);
          const horizontal = Math.max(0, targetX - startX);
          const tipX = startX + horizontal;
          const width = Math.max(startX, tipX) + arrowSize + 4;

          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.classList.add('arrow-svg');
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);
          svg.style.left = `${baseLeft}px`;
          svg.style.top = `${startY}px`;

          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M${startX} 1 v${vertical} h${horizontal}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', accent.trim() || '#00e5ff');
          path.setAttribute('stroke-width', ARROW_STROKE);
          path.setAttribute('stroke-linejoin', 'round');
          path.setAttribute('stroke-linecap', 'round');

          const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          const tipY = vertical + 1;
          arrowHead.setAttribute('d', `M${tipX - arrowSize} ${tipY - arrowSize} L${tipX} ${tipY} L${tipX - arrowSize} ${tipY + arrowSize}`);
          arrowHead.setAttribute('fill', 'none');
          arrowHead.setAttribute('stroke', accent.trim() || '#00e5ff');
          arrowHead.setAttribute('stroke-width', ARROW_STROKE);
          arrowHead.setAttribute('stroke-linecap', 'round');
          arrowHead.setAttribute('stroke-linejoin', 'round');

          svg.appendChild(path);
          svg.appendChild(arrowHead);
          this.arrowLayerEl.appendChild(svg);
        }
      }

      offsetWithinContainer(element) {
        if (!element) return 0;
        let offset = 0;
        let node = element;
        const container = this.slotsEl;
        while (node && node !== container) {
          offset += node.offsetTop || 0;
          node = node.offsetParent;
        }
        return offset;
      }

      offsetLeftWithinContainer(element) {
        if (!element) return 0;
        let offset = 0;
        let node = element;
        const container = this.slotsEl;
        while (node && node !== container) {
          offset += node.offsetLeft || 0;
          node = node.offsetParent;
        }
        return offset;
      }

      render() {
        const level = this.state.level;
        if (this.levelPillEl) this.levelPillEl.textContent = `Level ${level}`;
        if (this.headerLevelEl) this.headerLevelEl.textContent = `LEVEL ${level}`;
        if (this.levelDisplayEl) this.levelDisplayEl.textContent = `Viewing mastery unlocks at level ${level}.`;
        if (this.levelDownBtn) this.levelDownBtn.disabled = level === this.minLevel;
        if (this.levelUpBtn) this.levelUpBtn.disabled = level === this.maxLevel;
        if (this.progressBarEl) this.updateProgressUI(level);
        this.updateAp(level);
        if (!this.state.collapsed) {
          const build = this.buildById[this.activeBuildId];
          if (build && build.type !== 'mastery') {
            const stats = this.renderBuildAttachments(build);
            this.applyBuildApStats(stats);
            this.updateLevelDisplayForBuild(stats);
            this.renderChanges(level);
          } else {
            this.renderSlots(level);
            this.renderChanges(level);
            this.activeBuildNote = null;
            this.activeBuildApStats = null;
            this.updateLevelDisplayDefault(level);
          }
        }
        this.renderBuildView();
      }

      refreshLayout() {
        if (this.state.collapsed) return;
        this.renderSlots(this.state.level);
      }
    }
    const template = document.getElementById('weaponTemplate');
    const weaponListEl = document.getElementById('weaponList');
    const weaponNavEl = document.getElementById('weaponNav');
    const layoutGridEl = document.querySelector('.layout-grid');
    const floatingOptionsBtn = document.getElementById('optionsFloatingButton');

    function setTypeFilter(value) {
      currentTypeFilter = formatTypeKey(value || '');
      saveTypeFilter(value || '');
      updateTypeFilterSelection();
      renderWeaponList();
    }

    function updateTypeFilterSelection() {
      if (!typeFilterList) return;
      const buttons = Array.from(typeFilterList.querySelectorAll('.type-filter-item'));
      buttons.forEach((button) => {
        const key = formatTypeKey(button.dataset.type || '');
        button.classList.toggle('active', key === currentTypeFilter);
      });
    }

  function deriveDefaultTypeOrder(trackersList) {
    const trackersCopy = [...trackersList];
    trackersCopy.sort((a, b) => {
      const aIndex = TYPE_INDEX[a.typeKey] ?? TYPE_ORDER.length;
      const bIndex = TYPE_INDEX[b.typeKey] ?? TYPE_ORDER.length;
      if (aIndex !== bIndex) return aIndex - bIndex;
      return (a.displayName || '').localeCompare(b.displayName || '');
    });
    return trackersCopy.map((tracker) => tracker.id);
  }

    function populateTypeFilterList(trackersList) {
        if (!typeFilterList) return;
        const typeMap = new Map();
        for (const tracker of trackersList) {
          if (!tracker || !tracker.typeKey) continue;
          if (!typeMap.has(tracker.typeKey)) {
            const label = (tracker.displayType && tracker.displayType.trim()) || tracker.typeKey;
            typeMap.set(tracker.typeKey, label);
          }
        }
      const entries = Array.from(typeMap.entries()).sort((a, b) => a[1].localeCompare(b[1]));
      const chips = [
        '<button type="button" class="type-filter-item" data-type="">All</button>',
        '<button type="button" class="type-filter-item" data-type="favorites">Favorites</button>'
      ];
      for (const [key, label] of entries) {
        chips.push(`<button type="button" class="type-filter-item" data-type="${key}">${label}</button>`);
      }
      typeFilterList.innerHTML = chips.join('');
      updateTypeFilterSelection();
    }

    function computeBaseOrder(idToTracker) {
      const storedOrder = storage.getOrder();
      const baseOrder = [];
      const seen = new Set();
      for (const id of storedOrder) {
        if (idToTracker.has(id) && !seen.has(id)) {
          baseOrder.push(id);
          seen.add(id);
        }
      }
      for (const tracker of trackers) {
        if (!seen.has(tracker.id)) {
          baseOrder.push(tracker.id);
          seen.add(tracker.id);
        }
      }
      return baseOrder;
    }

    function mergeVisibleOrderWithFullList(visibleOrder, idToTracker) {
      const baseOrder = computeBaseOrder(idToTracker);
      const normalizedVisible = visibleOrder.filter((id) => idToTracker.has(id));
      const visibleSet = new Set(normalizedVisible);
      const remainder = baseOrder.filter((id) => !visibleSet.has(id));
      return normalizedVisible.concat(remainder);
    }

    function supportsLocalStorage() {
      try {
        if (typeof window === 'undefined' || !window.localStorage) return false;
        const testKey = '__bf6_meta_test';
        window.localStorage.setItem(testKey, testKey);
        window.localStorage.removeItem(testKey);
        return true;
      } catch {
        return false;
      }
    }

    function loadTypeFilter() {
      if (!supportsLocalStorage()) return '';
      try {
        const stored = window.localStorage.getItem(TYPE_FILTER_KEY);
        return typeof stored === 'string' ? stored : '';
      } catch {
        return '';
      }
    }

    function saveTypeFilter(value) {
      if (!supportsLocalStorage()) return;
      try {
        window.localStorage.setItem(TYPE_FILTER_KEY, value || '');
      } catch {}
    }

    function loadActiveTabs() {
      if (!supportsLocalStorage()) return {};
      try {
        const stored = window.localStorage.getItem(ACTIVE_TAB_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch {
        return {};
      }
    }

    function persistActiveTab(id, buildId) {
      if (!supportsLocalStorage()) return;
      try {
        activeTabMap[id] = buildId;
        window.localStorage.setItem(ACTIVE_TAB_STORAGE_KEY, JSON.stringify(activeTabMap));
      } catch {}
    }


    const trackers = weaponConfigs.map((config) => {
      const tracker = new WeaponTracker(config);
      tracker.mount(template);
      return tracker;
    });
    const trackerMap = new Map(trackers.map((tracker) => [tracker.id, tracker]));

    if (typeFilterList) {
      typeFilterList.addEventListener('click', (event) => {
        const button = event.target.closest('.type-filter-item');
        if (!button) return;
        setTypeFilter(button.dataset.type || '');
      });
    }
    populateTypeFilterList(trackers);

    function updateWeaponNav(order) {
      if (!weaponNavEl) return;
      const idToTracker = trackerMap;
      const ul = document.createElement('ul');
      ul.className = 'side-nav-list';
      for (const id of order) {
        const tracker = idToTracker.get(id);
        if (!tracker) continue;
        const li = document.createElement('li');
        li.className = 'side-nav-item';
        li.dataset.weaponId = id;
        enableNavDrag(li);
        const name = document.createElement('span');
        name.className = 'side-nav-name';
        const navName = tracker.displayName || (tracker.config && tracker.config.name) || id;
        name.textContent = toUpperSafe(navName);
        li.appendChild(name);
        const navType = tracker.displayType || (tracker.config && tracker.config.type);
        if (navType) {
          const type = document.createElement('span');
          type.className = 'side-nav-type';
          type.textContent = toUpperSafe(navType);
          li.appendChild(type);
        }
        if (tracker.isFavorite()) {
          const fav = document.createElement('span');
          fav.className = 'side-nav-fav';
          fav.setAttribute('aria-hidden', 'true');
          fav.textContent = '\u2605';
          li.appendChild(fav);
        }
        ul.appendChild(li);
      }
      weaponNavEl.innerHTML = '';
      weaponNavEl.appendChild(ul);
      weaponNavEl.classList.add("nav-ready");
    }

    function scrollToTracker(tracker) {
      if (!tracker || !tracker.cardEl) return;
      const rect = tracker.cardEl.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const viewportH = window.innerHeight || document.documentElement.clientHeight;
      let targetTop;
      if (!tracker.state.collapsed) {
        const mid = rect.top + scrollTop + rect.height / 2;
        targetTop = Math.max(0, Math.round(mid - viewportH / 2));
      } else {
        targetTop = Math.max(0, Math.round(rect.top + scrollTop - 24));
      }
      window.scrollTo({ top: targetTop, behavior: 'smooth' });
    }

    if (weaponNavEl) {
      weaponNavEl.addEventListener('click', (event) => {
        const item = event.target.closest('.side-nav-item');
        if (!item) return;
        const id = item.dataset.weaponId;
        const tracker = trackers.find((t) => t.id === id);
        scrollToTracker(tracker);
      });

      weaponNavEl.addEventListener('dragover', (event) => {
        if (!currentDraggedId) return;
        if (!weaponNavEl.contains(event.target)) return;
        const listEl = weaponNavEl.querySelector('.side-nav-list');
        if (!listEl) return;
        event.preventDefault();
        if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
        const placeholder = getNavDropPlaceholder();
        if (event.target === placeholder) return;
        const dropItem = event.target.closest('.side-nav-item');
        if (dropItem && dropItem !== placeholder) {
          const rect = dropItem.getBoundingClientRect();
          const before = event.clientY < rect.top + rect.height / 2;
          if (before) listEl.insertBefore(placeholder, dropItem);
          else listEl.insertBefore(placeholder, dropItem.nextSibling);
        } else if (placeholder.parentNode !== listEl) {
          listEl.appendChild(placeholder);
        }
      });

      weaponNavEl.addEventListener('drop', (event) => {
        if (!currentDraggedId) return;
        const listEl = weaponNavEl.querySelector('.side-nav-list');
        if (!listEl) return;
        const navItems = Array.from(listEl.children);
        if (!navItems.length) return;
        event.preventDefault();
        const dropItem = event.target.closest('.side-nav-item');
        const domOrder = navItems.map((item) => item.dataset.weaponId);
        const filteredOrder = domOrder.filter(Boolean);
        let insertIndex = filteredOrder.length;
        if (navDropPlaceholder && navDropPlaceholder.parentNode === listEl) {
          const placeholderIndex = navItems.indexOf(navDropPlaceholder);
          if (placeholderIndex !== -1) {
            const beforeNodes = navItems.slice(0, placeholderIndex);
            insertIndex = beforeNodes.reduce((count, node) => count + (node.dataset && node.dataset.weaponId ? 1 : 0), 0);
          }
        } else if (dropItem) {
          const dropId = dropItem.dataset.weaponId;
          if (dropId) {
            const dropIndex = filteredOrder.indexOf(dropId);
            if (dropIndex !== -1) {
              const rect = dropItem.getBoundingClientRect();
              const before = event.clientY < rect.top + rect.height / 2;
              insertIndex = before ? dropIndex : dropIndex + 1;
            }
          }
        }
        const order = filteredOrder.filter((id) => id && id !== currentDraggedId);
        if (insertIndex > order.length) insertIndex = order.length;
        order.splice(insertIndex, 0, currentDraggedId);
        const mergedOrder = mergeVisibleOrderWithFullList(order, trackerMap);
        storage.setOrder(mergedOrder);
        clearNavDropPlaceholder();
        renderWeaponList();
        currentDraggedId = null;
        setDragActiveState(false);
      });
    }

    function renderWeaponList() {
      const storedOrder = storage.getOrder();
      const idToTracker = trackerMap;
      const baseOrder = computeBaseOrder(idToTracker);

      const favorites = baseOrder.filter((id) => idToTracker.get(id).isFavorite());
      const others = baseOrder.filter((id) => !idToTracker.get(id).isFavorite());
      const finalOrder = favorites.concat(others);

      const storedMatches =
        storedOrder.length === finalOrder.length &&
        finalOrder.every((id, index) => storedOrder[index] === id);
      if (!storedMatches) {
        storage.setOrder(finalOrder);
      }

      weaponListEl.innerHTML = '';
      let displayOrder = finalOrder;
      if (currentTypeFilter === FAVORITES_FILTER) {
        displayOrder = finalOrder.filter((id) => {
          const tracker = idToTracker.get(id);
          return tracker && tracker.isFavorite();
        });
      } else if (currentTypeFilter) {
        const filtered = finalOrder
          .map((id) => idToTracker.get(id))
          .filter((tracker) => tracker && tracker.typeKey === currentTypeFilter);
        filtered.sort((a, b) => {
          const aVal = Number.isFinite(a.typeRatingValue) ? a.typeRatingValue : Number.MAX_SAFE_INTEGER;
          const bVal = Number.isFinite(b.typeRatingValue) ? b.typeRatingValue : Number.MAX_SAFE_INTEGER;
          if (aVal !== bVal) return aVal - bVal;
          return (a.displayName || '').localeCompare(b.displayName || '');
        });
        displayOrder = filtered.map((tracker) => tracker.id);
      } else {
        const defaultOrder = deriveDefaultTypeOrder(trackers);
        const matchesDefault =
          defaultOrder.length === finalOrder.length &&
          defaultOrder.every((id, index) => finalOrder[index] === id);
        displayOrder = matchesDefault ? defaultOrder : finalOrder;
      }
        for (const id of displayOrder) {
        const tracker = idToTracker.get(id);
        tracker.attach(weaponListEl);
      }
      const navOrder = currentTypeFilter ? displayOrder : finalOrder;
      updateWeaponNav(navOrder);
    }

    renderWeaponList();

    weaponListEl.addEventListener('dragover', (event) => {
      if (!currentDraggedId) return;
      event.preventDefault();
      if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
      const placeholder = getCardDropPlaceholder();
      if (event.target === placeholder) return;
      const dropCard = event.target.closest('.weapon-card');
      if (dropCard && dropCard !== placeholder) {
        const rect = dropCard.getBoundingClientRect();
        const before = event.clientY < rect.top + rect.height / 2;
        if (before) weaponListEl.insertBefore(placeholder, dropCard);
        else weaponListEl.insertBefore(placeholder, dropCard.nextSibling);
      } else if (placeholder.parentNode !== weaponListEl) {
        weaponListEl.appendChild(placeholder);
      }
    });

    weaponListEl.addEventListener('drop', (event) => {
      if (!currentDraggedId) return;
      event.preventDefault();
      const dropCard = event.target.closest('.weapon-card');
      const children = Array.from(weaponListEl.children);
      const domOrder = children.map((el) => el.dataset.weaponId);
      let insertIndex = domOrder.filter(Boolean).length;

      if (cardDropPlaceholder && cardDropPlaceholder.parentNode === weaponListEl) {
        const placeholderIndex = children.indexOf(cardDropPlaceholder);
        if (placeholderIndex !== -1) {
          const beforeNodes = children.slice(0, placeholderIndex);
          insertIndex = beforeNodes.reduce((count, node) => count + (node.dataset && node.dataset.weaponId ? 1 : 0), 0);
        }
      } else if (dropCard) {
        const dropId = dropCard.dataset.weaponId;
        const filteredOrder = domOrder.filter(Boolean);
        const dropIndex = filteredOrder.indexOf(dropId);
        if (dropIndex !== -1) {
          const rect = dropCard.getBoundingClientRect();
          const before = event.clientY < rect.top + rect.height / 2;
          insertIndex = before ? dropIndex : dropIndex + 1;
        }
      }

      const order = domOrder.filter((id) => id && id !== currentDraggedId);
      if (insertIndex > order.length) insertIndex = order.length;
      order.splice(insertIndex, 0, currentDraggedId);
      const mergedOrder = mergeVisibleOrderWithFullList(order, trackerMap);
      storage.setOrder(mergedOrder);
      clearCardDropPlaceholder();
      renderWeaponList();
      currentDraggedId = null;
    });

    window.addEventListener('resize', () => {
      trackers.forEach((tracker) => tracker.refreshLayout());
    });

    // UI Scale control & options setup
    (function setupUiScale() {
      const KEY = 'bf6-meta-ui-scale';
      const REDUCE_KEY = 'bf6-meta-reduce-animations';
      const OPTIONS_KEY = 'bf6-meta-options-visible';
      const valueEl = document.getElementById('uiScaleValue');
      const sliderEl = document.getElementById('uiScaleSlider');
      const optionsPanelEl = document.getElementById('uiScalePanel');
      const optionsGearBtn = document.getElementById('optionsGearButton');
      const reduceToggleEl = document.getElementById('reduceAnimationsToggle');
      const reduceToggleSwitch = reduceToggleEl ? reduceToggleEl.querySelector('.toggle-switch') : null;

      const MIN = 50;
      const MAX = 200;
      const STEP = 5;

      function loadBool(key, fallback) {
        if (!supportsLocalStorage()) return fallback;
        try {
          const stored = localStorage.getItem(key);
          if (stored === null || stored === undefined) return fallback;
          return stored === '1';
        } catch {
          return fallback;
        }
      }

      function saveBool(key, value) {
        if (!supportsLocalStorage()) return;
        try {
          localStorage.setItem(key, value ? '1' : '0');
        } catch (_) {}
      }

      function clampPercent(p) {
        p = Math.round(Number(p) || 100);
        if (p < MIN) p = MIN;
        if (p > MAX) p = MAX;
        return p;
      }

      function quantize(p) {
        const clamped = clampPercent(p);
        const stepsFromMin = Math.round((clamped - MIN) / STEP);
        return MIN + stepsFromMin * STEP;
      }

      function updateUiScaleUI(value, syncSlider = true) {
        if (valueEl) valueEl.textContent = value + '%';
        if (sliderEl) {
          if (syncSlider) sliderEl.value = String(value);
          const fill = ((value - MIN) / (MAX - MIN)) * 100;
          sliderEl.style.setProperty('--slider-fill', fill + '%');
          sliderEl.setAttribute('aria-valuenow', String(value));
        }
      }

      function applyScale(percent) {
        const p = quantize(percent);
        document.documentElement.style.setProperty('--ui-scale', (p / 100).toString());
        try { localStorage.setItem(KEY, String(p)); } catch (_) {}
        pendingScale = p;
        updateUiScaleUI(p);
      }

      let initial = 100;
      try {
        const raw = localStorage.getItem(KEY);
        const num = parseInt(raw || '100', 10);
        if (Number.isFinite(num)) initial = clampPercent(num);
      } catch (_) {}
      let pendingScale = initial;
      function applyReduceAnimationsPref(enabled) {
        document.documentElement.classList.toggle('reduce-animations', enabled);
        if (reduceToggleEl) {
          reduceToggleEl.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        }
        if (reduceToggleSwitch) {
          reduceToggleSwitch.classList.toggle('on', enabled);
        }
      }

      function applyOptionsVisibility(visible) {
        if (!optionsPanelEl) return;
        optionsPanelEl.hidden = !visible;
        optionsPanelEl.classList.toggle('collapsed', !visible);
        optionsPanelEl.setAttribute('aria-hidden', visible ? 'false' : 'true');
        if (layoutGridEl) {
          layoutGridEl.classList.toggle('options-hidden', !visible);
        }
        if (optionsGearBtn) {
          optionsGearBtn.setAttribute('aria-expanded', visible ? 'true' : 'false');
          optionsGearBtn.setAttribute('aria-label', visible ? 'Hide options' : 'Show options');
        }
        if (floatingOptionsBtn) {
          floatingOptionsBtn.hidden = visible;
          floatingOptionsBtn.setAttribute('aria-hidden', visible ? 'true' : 'false');
          floatingOptionsBtn.setAttribute('aria-expanded', visible ? 'true' : 'false');
          floatingOptionsBtn.setAttribute('aria-label', visible ? 'Hide options' : 'Show options');
        }
      }

      const reducePref = loadBool(REDUCE_KEY, false);
      applyReduceAnimationsPref(reducePref);

      if (reduceToggleEl) {
        reduceToggleEl.addEventListener('click', () => {
          const next = reduceToggleEl.getAttribute('aria-pressed') !== 'true';
          applyReduceAnimationsPref(next);
          saveBool(REDUCE_KEY, next);
        });
      }

      const optionsVisible = loadBool(OPTIONS_KEY, true);
      applyOptionsVisibility(optionsVisible);

      if (optionsGearBtn && optionsPanelEl) {
        optionsGearBtn.addEventListener('click', () => {
          const currentlyVisible = !optionsPanelEl.hidden;
          const next = !currentlyVisible;
          applyOptionsVisibility(next);
          saveBool(OPTIONS_KEY, next);
        });
      }

      if (floatingOptionsBtn) {
        floatingOptionsBtn.addEventListener('click', () => {
          applyOptionsVisibility(true);
          saveBool(OPTIONS_KEY, true);
        });
      }

      if (sliderEl) {
        sliderEl.setAttribute('min', String(MIN));
        sliderEl.setAttribute('max', String(MAX));
        sliderEl.setAttribute('step', String(STEP));
        sliderEl.addEventListener('input', (event) => {
          const target = event.currentTarget;
          if (!(target instanceof HTMLInputElement)) return;
          const raw = Number(target.value);
          if (!Number.isFinite(raw)) return;
          const preview = quantize(raw);
          pendingScale = preview;
          updateUiScaleUI(preview, false);
        });
        const commitScale = () => applyScale(pendingScale);
        sliderEl.addEventListener('change', commitScale);
        sliderEl.addEventListener('pointerup', commitScale);
      }

      applyScale(initial);
    })();
  </script>
</body>
</html>

